diff --git a/C/LzmaEnc.c b/C/LzmaEnc.c
index 9b7e691..46a0db0 100644
--- a/C/LzmaEnc.c
+++ b/C/LzmaEnc.c
@@ -594,78 +594,121 @@ Hunk #19, a/C/LzmaEnc.c static void RangeEnc_FlushData(CRangeEnc *p)
     RangeEnc_ShiftLow(p);
 }
 
-static void RangeEnc_EncodeDirectBits(CRangeEnc *p, UInt32 value, unsigned numBits)
+#define RC_NORM(p) if (range < kTopValue) { range <<= 8; RangeEnc_ShiftLow(p); }
+
+#define RC_BIT_PRE(p, prob) \
+  ttt = *(prob); \
+  newBound = (range >> kNumBitModelTotalBits) * ttt;
+
+// #define _LZMA_ENC_USE_BRANCH
+
+#ifdef _LZMA_ENC_USE_BRANCH
+
+#define RC_BIT(p, prob, bit) { \
+  RC_BIT_PRE(p, prob) \
+  if (bit == 0) { range = newBound; ttt += (kBitModelTotal - ttt) >> kNumMoveBits; } \
+  else { (p)->low += newBound; range -= newBound; ttt -= ttt >> kNumMoveBits; } \
+  *(prob) = (CLzmaProb)ttt; \
+  RC_NORM(p) \
+  }
+
+#else
+
+#define RC_BIT(p, prob, bit) { \
+  UInt32 mask; \
+  RC_BIT_PRE(p, prob) \
+  mask = 0 - (UInt32)bit; \
+  range &= mask; \
+  mask &= newBound; \
+  range -= mask; \
+  (p)->low += mask; \
+  mask = (UInt32)bit - 1; \
+  range += newBound & mask; \
+  mask &= (kBitModelTotal - ((1 << kNumMoveBits) - 1)); \
+  mask += ((1 << kNumMoveBits) - 1); \
+  ttt += (Int32)(mask - ttt) >> kNumMoveBits; \
+  *(prob) = (CLzmaProb)ttt; \
+  RC_NORM(p) \
+  }
+
+#endif
+
+
+
+
+#define RC_BIT_0_BASE(p, prob) \
+  range = newBound; *(prob) = (CLzmaProb)(ttt + ((kBitModelTotal - ttt) >> kNumMoveBits));
+
+#define RC_BIT_1_BASE(p, prob) \
+  range -= newBound; (p)->low += newBound; *(prob) = (CLzmaProb)(ttt - (ttt >> kNumMoveBits)); \
+
+#define RC_BIT_0(p, prob) \
+  RC_BIT_0_BASE(p, prob) \
+  RC_NORM(p)
+
+#define RC_BIT_1(p, prob) \
+  RC_BIT_1_BASE(p, prob) \
+  RC_NORM(p)
+
+static void RangeEnc_EncodeBit_0(CRangeEnc *p, CLzmaProb *prob)
 {
+  UInt32 range, ttt, newBound;
+  range = p->range;
+  RC_BIT_PRE(p, prob)
+  RC_BIT_0(p, prob)
+  p->range = range;
+}
+
+static void LitEnc_Encode(CRangeEnc *p, CLzmaProb *probs, UInt32 sym)
+{
+  UInt32 range = p->range;
+  sym |= 0x100;
   do
   {
-    p->range >>= 1;
-    p->low += p->range & (0 - ((value >> --numBits) & 1));
-    if (p->range < kTopValue)
-    {
-      p->range <<= 8;
-      RangeEnc_ShiftLow(p);
-    }
+    UInt32 ttt, newBound;
+    // RangeEnc_EncodeBit(p, probs + (sym >> 8), (sym >> 7) & 1);
+    CLzmaProb *prob = probs + (sym >> 8);
+    UInt32 bit = (sym >> 7) & 1;
+    sym <<= 1;
+    RC_BIT(p, prob, bit);
   }
-  while (numBits != 0);
+  while (sym < 0x10000);
+  p->range = range;
 }
 
-static void RangeEnc_EncodeBit(CRangeEnc *p, CLzmaProb *prob, UInt32 symbol)
-{
-  UInt32 ttt = *prob;
-  UInt32 newBound = (p->range >> kNumBitModelTotalBits) * ttt;
-  if (symbol == 0)
-  {
-    p->range = newBound;
-    ttt += (kBitModelTotal - ttt) >> kNumMoveBits;
-  }
-  else
-  {
-    p->low += newBound;
-    p->range -= newBound;
-    ttt -= ttt >> kNumMoveBits;
-  }
-  *prob = (CLzmaProb)ttt;
-  if (p->range < kTopValue)
-  {
-    p->range <<= 8;
-    RangeEnc_ShiftLow(p);
-  }
-}
-
-static void LitEnc_Encode(CRangeEnc *p, CLzmaProb *probs, UInt32 symbol)
-{
-  symbol |= 0x100;
-  do
-  {
-    RangeEnc_EncodeBit(p, probs + (symbol >> 8), (symbol >> 7) & 1);
-    symbol <<= 1;
-  }
-  while (symbol < 0x10000);
-}
-
-static void LitEnc_EncodeMatched(CRangeEnc *p, CLzmaProb *probs, UInt32 symbol, UInt32 matchByte)
+static void LitEnc_EncodeMatched(CRangeEnc *p, CLzmaProb *probs, UInt32 sym, UInt32 matchByte)
 {
+  UInt32 range = p->range;
   UInt32 offs = 0x100;
-  symbol |= 0x100;
+  sym |= 0x100;
   do
   {
+    UInt32 ttt, newBound;
+    CLzmaProb *prob;
+    UInt32 bit;
     matchByte <<= 1;
-    RangeEnc_EncodeBit(p, probs + (offs + (matchByte & offs) + (symbol >> 8)), (symbol >> 7) & 1);
-    symbol <<= 1;
-    offs &= ~(matchByte ^ symbol);
+    // RangeEnc_EncodeBit(p, probs + (offs + (matchByte & offs) + (sym >> 8)), (sym >> 7) & 1);
+    prob = probs + (offs + (matchByte & offs) + (sym >> 8));
+    bit = (sym >> 7) & 1;
+    sym <<= 1;
+    offs &= ~(matchByte ^ sym);
+    RC_BIT(p, prob, bit);
   }
-  while (symbol < 0x10000);
+  while (sym < 0x10000);
+  p->range = range;
 }
 
-static void LzmaEnc_InitPriceTables(UInt32 *ProbPrices)
+
+
+static void LzmaEnc_InitPriceTables(CProbPrice *ProbPrices)
 {
   UInt32 i;
-  for (i = (1 << kNumMoveReducingBits) / 2; i < kBitModelTotal; i += (1 << kNumMoveReducingBits))
+  for (i = 0; i < (kBitModelTotal >> kNumMoveReducingBits); i++)
   {
-    const int kCyclesBits = kNumBitPriceShiftBits;
-    UInt32 w = i;
-    UInt32 bitCount = 0;
-    int j;
+    const unsigned kCyclesBits = kNumBitPriceShiftBits;
+    UInt32 w = (i << kNumMoveReducingBits) + (1 << (kNumMoveReducingBits - 1));
+    unsigned bitCount = 0;
+    unsigned j;
     for (j = 0; j < kCyclesBits; j++)
     {
       w = w * w;
