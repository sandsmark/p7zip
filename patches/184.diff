diff --git a/C/LzmaEnc.c b/C/LzmaEnc.c
index 9b7e691..46a0db0 100644
--- a/C/LzmaEnc.c
+++ b/C/LzmaEnc.c
@@ -676,567 +676,655 @@ Hunk #20, a/C/LzmaEnc.c static void LzmaEnc_InitPriceTables(UInt32 *ProbPrices)
         bitCount++;
       }
     }
-    ProbPrices[i >> kNumMoveReducingBits] = ((kNumBitModelTotalBits << kCyclesBits) - 15 - bitCount);
+    ProbPrices[i] = (CProbPrice)((kNumBitModelTotalBits << kCyclesBits) - 15 - bitCount);
+    // printf("\n%3d: %5d", i, ProbPrices[i]);
   }
 }
 
 
-#define GET_PRICE(prob, symbol) \
-  p->ProbPrices[((prob) ^ (((-(int)(symbol))) & (kBitModelTotal - 1))) >> kNumMoveReducingBits];
+#define GET_PRICE(prob, bit) \
+  p->ProbPrices[((prob) ^ (unsigned)(((-(int)(bit))) & (kBitModelTotal - 1))) >> kNumMoveReducingBits];
 
-#define GET_PRICEa(prob, symbol) \
-  ProbPrices[((prob) ^ ((-((int)(symbol))) & (kBitModelTotal - 1))) >> kNumMoveReducingBits];
+#define GET_PRICEa(prob, bit) \
+     ProbPrices[((prob) ^ (unsigned)((-((int)(bit))) & (kBitModelTotal - 1))) >> kNumMoveReducingBits];
 
 #define GET_PRICE_0(prob) p->ProbPrices[(prob) >> kNumMoveReducingBits]
 #define GET_PRICE_1(prob) p->ProbPrices[((prob) ^ (kBitModelTotal - 1)) >> kNumMoveReducingBits]
 
-#define GET_PRICE_0a(prob) ProbPrices[(prob) >> kNumMoveReducingBits]
-#define GET_PRICE_1a(prob) ProbPrices[((prob) ^ (kBitModelTotal - 1)) >> kNumMoveReducingBits]
+#define GET_PRICEa_0(prob) ProbPrices[(prob) >> kNumMoveReducingBits]
+#define GET_PRICEa_1(prob) ProbPrices[((prob) ^ (kBitModelTotal - 1)) >> kNumMoveReducingBits]
 
-static UInt32 LitEnc_GetPrice(const CLzmaProb *probs, UInt32 symbol, const UInt32 *ProbPrices)
+
+static UInt32 LitEnc_GetPrice(const CLzmaProb *probs, UInt32 sym, const CProbPrice *ProbPrices)
 {
   UInt32 price = 0;
-  symbol |= 0x100;
+  sym |= 0x100;
   do
   {
-    price += GET_PRICEa(probs[symbol >> 8], (symbol >> 7) & 1);
-    symbol <<= 1;
+    unsigned bit = sym & 1;
+    sym >>= 1;
+    price += GET_PRICEa(probs[sym], bit);
   }
-  while (symbol < 0x10000);
+  while (sym >= 2);
   return price;
 }
 
-static UInt32 LitEnc_GetPriceMatched(const CLzmaProb *probs, UInt32 symbol, UInt32 matchByte, const UInt32 *ProbPrices)
+
+static UInt32 LitEnc_Matched_GetPrice(const CLzmaProb *probs, UInt32 sym, UInt32 matchByte, const CProbPrice *ProbPrices)
 {
   UInt32 price = 0;
   UInt32 offs = 0x100;
-  symbol |= 0x100;
+  sym |= 0x100;
   do
   {
     matchByte <<= 1;
-    price += GET_PRICEa(probs[offs + (matchByte & offs) + (symbol >> 8)], (symbol >> 7) & 1);
-    symbol <<= 1;
-    offs &= ~(matchByte ^ symbol);
+    price += GET_PRICEa(probs[offs + (matchByte & offs) + (sym >> 8)], (sym >> 7) & 1);
+    sym <<= 1;
+    offs &= ~(matchByte ^ sym);
   }
-  while (symbol < 0x10000);
+  while (sym < 0x10000);
   return price;
 }
 
 
-static void RcTree_Encode(CRangeEnc *rc, CLzmaProb *probs, int numBitLevels, UInt32 symbol)
+static void RcTree_ReverseEncode(CRangeEnc *rc, CLzmaProb *probs, unsigned numBits, unsigned sym)
 {
-  UInt32 m = 1;
-  int i;
-  for (i = numBitLevels; i != 0;)
+  UInt32 range = rc->range;
+  unsigned m = 1;
+  do
   {
-    UInt32 bit;
-    i--;
-    bit = (symbol >> i) & 1;
-    RangeEnc_EncodeBit(rc, probs + m, bit);
+    UInt32 ttt, newBound;
+    unsigned bit = sym & 1;
+    // RangeEnc_EncodeBit(rc, probs + m, bit);
+    sym >>= 1;
+    RC_BIT(rc, probs + m, bit);
     m = (m << 1) | bit;
   }
+  while (--numBits);
+  rc->range = range;
 }
 
-static void RcTree_ReverseEncode(CRangeEnc *rc, CLzmaProb *probs, int numBitLevels, UInt32 symbol)
-{
-  UInt32 m = 1;
-  int i;
-  for (i = 0; i < numBitLevels; i++)
-  {
-    UInt32 bit = symbol & 1;
-    RangeEnc_EncodeBit(rc, probs + m, bit);
-    m = (m << 1) | bit;
-    symbol >>= 1;
-  }
-}
-
-static UInt32 RcTree_GetPrice(const CLzmaProb *probs, int numBitLevels, UInt32 symbol, const UInt32 *ProbPrices)
-{
-  UInt32 price = 0;
-  symbol |= (1 << numBitLevels);
-  while (symbol != 1)
-  {
-    price += GET_PRICEa(probs[symbol >> 1], symbol & 1);
-    symbol >>= 1;
-  }
-  return price;
-}
-
-static UInt32 RcTree_ReverseGetPrice(const CLzmaProb *probs, int numBitLevels, UInt32 symbol, const UInt32 *ProbPrices)
-{
-  UInt32 price = 0;
-  UInt32 m = 1;
-  int i;
-  for (i = numBitLevels; i != 0; i--)
-  {
-    UInt32 bit = symbol & 1;
-    symbol >>= 1;
-    price += GET_PRICEa(probs[m], bit);
-    m = (m << 1) | bit;
-  }
-  return price;
-}
 
 
 static void LenEnc_Init(CLenEnc *p)
 {
   unsigned i;
-  p->choice = p->choice2 = kProbInitValue;
-  for (i = 0; i < (LZMA_NUM_PB_STATES_MAX << kLenNumLowBits); i++)
+  for (i = 0; i < (LZMA_NUM_PB_STATES_MAX << (kLenNumLowBits + 1)); i++)
     p->low[i] = kProbInitValue;
-  for (i = 0; i < (LZMA_NUM_PB_STATES_MAX << kLenNumMidBits); i++)
-    p->mid[i] = kProbInitValue;
   for (i = 0; i < kLenNumHighSymbols; i++)
     p->high[i] = kProbInitValue;
 }
 
-static void LenEnc_Encode(CLenEnc *p, CRangeEnc *rc, UInt32 symbol, UInt32 posState)
+static void LenEnc_Encode(CLenEnc *p, CRangeEnc *rc, unsigned sym, unsigned posState)
 {
-  if (symbol < kLenNumLowSymbols)
+  UInt32 range, ttt, newBound;
+  CLzmaProb *probs = p->low;
+  range = rc->range;
+  RC_BIT_PRE(rc, probs);
+  if (sym >= kLenNumLowSymbols)
   {
-    RangeEnc_EncodeBit(rc, &p->choice, 0);
-    RcTree_Encode(rc, p->low + (posState << kLenNumLowBits), kLenNumLowBits, symbol);
-  }
-  else
-  {
-    RangeEnc_EncodeBit(rc, &p->choice, 1);
-    if (symbol < kLenNumLowSymbols + kLenNumMidSymbols)
+    RC_BIT_1(rc, probs);
+    probs += kLenNumLowSymbols;
+    RC_BIT_PRE(rc, probs);
+    if (sym >= kLenNumLowSymbols * 2)
     {
-      RangeEnc_EncodeBit(rc, &p->choice2, 0);
-      RcTree_Encode(rc, p->mid + (posState << kLenNumMidBits), kLenNumMidBits, symbol - kLenNumLowSymbols);
+      RC_BIT_1(rc, probs);
+      rc->range = range;
+      // RcTree_Encode(rc, p->high, kLenNumHighBits, sym - kLenNumLowSymbols * 2);
+      LitEnc_Encode(rc, p->high, sym - kLenNumLowSymbols * 2);
+      return;
     }
-    else
+    sym -= kLenNumLowSymbols;
+  }
+
+  // RcTree_Encode(rc, probs + (posState << kLenNumLowBits), kLenNumLowBits, sym);
+  {
+    unsigned m;
+    unsigned bit;
+    RC_BIT_0(rc, probs);
+    probs += (posState << (1 + kLenNumLowBits));
+    bit = (sym >> 2)    ; RC_BIT(rc, probs + 1, bit); m = (1 << 1) + bit;
+    bit = (sym >> 1) & 1; RC_BIT(rc, probs + m, bit); m = (m << 1) + bit;
+    bit =  sym       & 1; RC_BIT(rc, probs + m, bit);
+    rc->range = range;
+  }
+}
+
+static void SetPrices_3(const CLzmaProb *probs, UInt32 startPrice, UInt32 *prices, const CProbPrice *ProbPrices)
+{
+  unsigned i;
+  for (i = 0; i < 8; i += 2)
+  {
+    UInt32 price = startPrice;
+    UInt32 prob;
+    price += GET_PRICEa(probs[1           ], (i >> 2));
+    price += GET_PRICEa(probs[2 + (i >> 2)], (i >> 1) & 1);
+    prob = probs[4 + (i >> 1)];
+    prices[i    ] = price + GET_PRICEa_0(prob);
+    prices[i + 1] = price + GET_PRICEa_1(prob);
+  }
+}
+
+
+MY_NO_INLINE static void MY_FAST_CALL LenPriceEnc_UpdateTables(
+    CLenPriceEnc *p,
+    unsigned numPosStates,
+    const CLenEnc *enc,
+    const CProbPrice *ProbPrices)
+{
+  UInt32 b;
+ 
+  {
+    unsigned prob = enc->low[0];
+    UInt32 a, c;
+    unsigned posState;
+    b = GET_PRICEa_1(prob);
+    a = GET_PRICEa_0(prob);
+    c = b + GET_PRICEa_0(enc->low[kLenNumLowSymbols]);
+    for (posState = 0; posState < numPosStates; posState++)
     {
-      RangeEnc_EncodeBit(rc, &p->choice2, 1);
-      RcTree_Encode(rc, p->high, kLenNumHighBits, symbol - kLenNumLowSymbols - kLenNumMidSymbols);
+      UInt32 *prices = p->prices[posState];
+      const CLzmaProb *probs = enc->low + (posState << (1 + kLenNumLowBits));
+      SetPrices_3(probs, a, prices, ProbPrices);
+      SetPrices_3(probs + kLenNumLowSymbols, c, prices + kLenNumLowSymbols, ProbPrices);
+    }
+  }
+
+  /*
+  {
+    unsigned i;
+    UInt32 b;
+    a = GET_PRICEa_0(enc->low[0]);
+    for (i = 0; i < kLenNumLowSymbols; i++)
+      p->prices2[i] = a;
+    a = GET_PRICEa_1(enc->low[0]);
+    b = a + GET_PRICEa_0(enc->low[kLenNumLowSymbols]);
+    for (i = kLenNumLowSymbols; i < kLenNumLowSymbols * 2; i++)
+      p->prices2[i] = b;
+    a += GET_PRICEa_1(enc->low[kLenNumLowSymbols]);
+  }
+  */
+ 
+  // p->counter = numSymbols;
+  // p->counter = 64;
+
+  {
+    unsigned i = p->tableSize;
+    
+    if (i > kLenNumLowSymbols * 2)
+    {
+      const CLzmaProb *probs = enc->high;
+      UInt32 *prices = p->prices[0] + kLenNumLowSymbols * 2;
+      i -= kLenNumLowSymbols * 2 - 1;
+      i >>= 1;
+      b += GET_PRICEa_1(enc->low[kLenNumLowSymbols]);
+      do
+      {
+        /*
+        p->prices2[i] = a +
+        // RcTree_GetPrice(enc->high, kLenNumHighBits, i - kLenNumLowSymbols * 2, ProbPrices);
+        LitEnc_GetPrice(probs, i - kLenNumLowSymbols * 2, ProbPrices);
+        */
+        // UInt32 price = a + RcTree_GetPrice(probs, kLenNumHighBits - 1, sym, ProbPrices);
+        unsigned sym = --i + (1 << (kLenNumHighBits - 1));
+        UInt32 price = b;
+        do
+        {
+          unsigned bit = sym & 1;
+          sym >>= 1;
+          price += GET_PRICEa(probs[sym], bit);
+        }
+        while (sym >= 2);
+
+        {
+          unsigned prob = probs[(size_t)i + (1 << (kLenNumHighBits - 1))];
+          prices[(size_t)i * 2    ] = price + GET_PRICEa_0(prob);
+          prices[(size_t)i * 2 + 1] = price + GET_PRICEa_1(prob);
+        }
+      }
+      while (i);
+
+      {
+        unsigned posState;
+        size_t num = (p->tableSize - kLenNumLowSymbols * 2) * sizeof(p->prices[0][0]);
+        for (posState = 1; posState < numPosStates; posState++)
+          memcpy(p->prices[posState] + kLenNumLowSymbols * 2, p->prices[0] + kLenNumLowSymbols * 2, num);
+      }
     }
   }
 }
 
-static void LenEnc_SetPrices(CLenEnc *p, UInt32 posState, UInt32 numSymbols, UInt32 *prices, const UInt32 *ProbPrices)
-{
-  UInt32 a0 = GET_PRICE_0a(p->choice);
-  UInt32 a1 = GET_PRICE_1a(p->choice);
-  UInt32 b0 = a1 + GET_PRICE_0a(p->choice2);
-  UInt32 b1 = a1 + GET_PRICE_1a(p->choice2);
-  UInt32 i = 0;
-  for (i = 0; i < kLenNumLowSymbols; i++)
-  {
-    if (i >= numSymbols)
-      return;
-    prices[i] = a0 + RcTree_GetPrice(p->low + (posState << kLenNumLowBits), kLenNumLowBits, i, ProbPrices);
-  }
-  for (; i < kLenNumLowSymbols + kLenNumMidSymbols; i++)
-  {
-    if (i >= numSymbols)
-      return;
-    prices[i] = b0 + RcTree_GetPrice(p->mid + (posState << kLenNumMidBits), kLenNumMidBits, i - kLenNumLowSymbols, ProbPrices);
-  }
-  for (; i < numSymbols; i++)
-    prices[i] = b1 + RcTree_GetPrice(p->high, kLenNumHighBits, i - kLenNumLowSymbols - kLenNumMidSymbols, ProbPrices);
-}
-
-static void MY_FAST_CALL LenPriceEnc_UpdateTable(CLenPriceEnc *p, UInt32 posState, const UInt32 *ProbPrices)
-{
-  LenEnc_SetPrices(&p->p, posState, p->tableSize, p->prices[posState], ProbPrices);
-  p->counters[posState] = p->tableSize;
-}
-
-static void LenPriceEnc_UpdateTables(CLenPriceEnc *p, UInt32 numPosStates, const UInt32 *ProbPrices)
-{
-  UInt32 posState;
-  for (posState = 0; posState < numPosStates; posState++)
-    LenPriceEnc_UpdateTable(p, posState, ProbPrices);
-}
-
-static void LenEnc_Encode2(CLenPriceEnc *p, CRangeEnc *rc, UInt32 symbol, UInt32 posState, Bool updatePrice, const UInt32 *ProbPrices)
-{
-  LenEnc_Encode(&p->p, rc, symbol, posState);
-  if (updatePrice)
-    if (--p->counters[posState] == 0)
-      LenPriceEnc_UpdateTable(p, posState, ProbPrices);
-}
-
-
-
-
-static void MovePos(CLzmaEnc *p, UInt32 num)
-{
+/*
   #ifdef SHOW_STAT
   g_STAT_OFFSET += num;
   printf("\n MovePos %u", num);
   #endif
+*/
   
-  if (num != 0)
-  {
-    p->additionalOffset += num;
-    p->matchFinder.Skip(p->matchFinderObj, num);
-  }
-}
+#define MOVE_POS(p, num) { \
+    p->additionalOffset += (num); \
+    p->matchFinder.Skip(p->matchFinderObj, (UInt32)(num)); }
 
-static UInt32 ReadMatchDistances(CLzmaEnc *p, UInt32 *numDistancePairsRes)
+
+static unsigned ReadMatchDistances(CLzmaEnc *p, unsigned *numPairsRes)
 {
-  UInt32 lenRes = 0, numPairs;
+  unsigned numPairs;
+  
+  p->additionalOffset++;
   p->numAvail = p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);
   numPairs = p->matchFinder.GetMatches(p->matchFinderObj, p->matches);
+  *numPairsRes = numPairs;
   
   #ifdef SHOW_STAT
   printf("\n i = %u numPairs = %u    ", g_STAT_OFFSET, numPairs / 2);
   g_STAT_OFFSET++;
   {
-    UInt32 i;
+    unsigned i;
     for (i = 0; i < numPairs; i += 2)
       printf("%2u %6u   | ", p->matches[i], p->matches[i + 1]);
   }
   #endif
   
-  if (numPairs > 0)
+  if (numPairs == 0)
+    return 0;
   {
-    lenRes = p->matches[(size_t)numPairs - 2];
-    if (lenRes == p->numFastBytes)
+    unsigned len = p->matches[(size_t)numPairs - 2];
+    if (len != p->numFastBytes)
+      return len;
     {
       UInt32 numAvail = p->numAvail;
       if (numAvail > LZMA_MATCH_LEN_MAX)
         numAvail = LZMA_MATCH_LEN_MAX;
       {
-        const Byte *pbyCur = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
-        const Byte *pby = pbyCur + lenRes;
+        const Byte *p1 = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
+        const Byte *p2 = p1 + len;
         ptrdiff_t dif = (ptrdiff_t)-1 - p->matches[(size_t)numPairs - 1];
-        const Byte *pbyLim = pbyCur + numAvail;
-        for (; pby != pbyLim && *pby == pby[dif]; pby++);
-        lenRes = (UInt32)(pby - pbyCur);
+        const Byte *lim = p1 + numAvail;
+        for (; p2 != lim && *p2 == p2[dif]; p2++)
+        {}
+        return (unsigned)(p2 - p1);
       }
     }
   }
-  p->additionalOffset++;
-  *numDistancePairsRes = numPairs;
-  return lenRes;
 }
 
+#define MARK_LIT ((UInt32)(Int32)-1)
 
-#define MakeAsChar(p) (p)->backPrev = (UInt32)(-1); (p)->prev1IsChar = False;
-#define MakeAsShortRep(p) (p)->backPrev = 0; (p)->prev1IsChar = False;
-#define IsShortRep(p) ((p)->backPrev == 0)
+#define MakeAs_Lit(p)       { (p)->dist = MARK_LIT; (p)->extra = 0; }
+#define MakeAs_ShortRep(p)  { (p)->dist = 0; (p)->extra = 0; }
+#define IsShortRep(p)       ((p)->dist == 0)
 
-static UInt32 GetRepLen1Price(CLzmaEnc *p, UInt32 state, UInt32 posState)
-{
-  return
-    GET_PRICE_0(p->isRepG0[state]) +
-    GET_PRICE_0(p->isRep0Long[state][posState]);
-}
 
-static UInt32 GetPureRepPrice(CLzmaEnc *p, UInt32 repIndex, UInt32 state, UInt32 posState)
+#define GetPrice_ShortRep(p, state, posState) \
+  ( GET_PRICE_0(p->isRepG0[state]) + GET_PRICE_0(p->isRep0Long[state][posState]))
+
+#define GetPrice_Rep_0(p, state, posState) ( \
+    GET_PRICE_1(p->isMatch[state][posState]) \
+  + GET_PRICE_1(p->isRep0Long[state][posState])) \
+  + GET_PRICE_1(p->isRep[state]) \
+  + GET_PRICE_0(p->isRepG0[state])
+  
+MY_FORCE_INLINE
+static UInt32 GetPrice_PureRep(const CLzmaEnc *p, unsigned repIndex, size_t state, size_t posState)
 {
   UInt32 price;
+  UInt32 prob = p->isRepG0[state];
   if (repIndex == 0)
   {
-    price = GET_PRICE_0(p->isRepG0[state]);
+    price = GET_PRICE_0(prob);
     price += GET_PRICE_1(p->isRep0Long[state][posState]);
   }
   else
   {
-    price = GET_PRICE_1(p->isRepG0[state]);
+    price = GET_PRICE_1(prob);
+    prob = p->isRepG1[state];
     if (repIndex == 1)
-      price += GET_PRICE_0(p->isRepG1[state]);
+      price += GET_PRICE_0(prob);
     else
     {
-      price += GET_PRICE_1(p->isRepG1[state]);
+      price += GET_PRICE_1(prob);
       price += GET_PRICE(p->isRepG2[state], repIndex - 2);
     }
   }
   return price;
 }
 
-static UInt32 GetRepPrice(CLzmaEnc *p, UInt32 repIndex, UInt32 len, UInt32 state, UInt32 posState)
-{
-  return p->repLenEnc.prices[posState][(size_t)len - LZMA_MATCH_LEN_MIN] +
-    GetPureRepPrice(p, repIndex, state, posState);
-}
 
-static UInt32 Backward(CLzmaEnc *p, UInt32 *backRes, UInt32 cur)
+static unsigned Backward(CLzmaEnc *p, unsigned cur)
 {
-  UInt32 posMem = p->opt[cur].posPrev;
-  UInt32 backMem = p->opt[cur].backPrev;
-  p->optimumEndIndex = cur;
-  do
+  unsigned wr = cur + 1;
+  p->optEnd = wr;
+
+  for (;;)
   {
-    if (p->opt[cur].prev1IsChar)
+    UInt32 dist = p->opt[cur].dist;
+    unsigned len = (unsigned)p->opt[cur].len;
+    unsigned extra = (unsigned)p->opt[cur].extra;
+    cur -= len;
+
+    if (extra)
     {
-      MakeAsChar(&p->opt[posMem])
-      p->opt[posMem].posPrev = posMem - 1;
-      if (p->opt[cur].prev2)
+      wr--;
+      p->opt[wr].len = (UInt32)len;
+      cur -= extra;
+      len = extra;
+      if (extra == 1)
       {
-        p->opt[(size_t)posMem - 1].prev1IsChar = False;
-        p->opt[(size_t)posMem - 1].posPrev = p->opt[cur].posPrev2;
-        p->opt[(size_t)posMem - 1].backPrev = p->opt[cur].backPrev2;
+        p->opt[wr].dist = dist;
+        dist = MARK_LIT;
+      }
+      else
+      {
+        p->opt[wr].dist = 0;
+        len--;
+        wr--;
+        p->opt[wr].dist = MARK_LIT;
+        p->opt[wr].len = 1;
       }
     }
+
+    if (cur == 0)
     {
-      UInt32 posPrev = posMem;
-      UInt32 backCur = backMem;
-      
-      backMem = p->opt[posPrev].backPrev;
-      posMem = p->opt[posPrev].posPrev;
-      
-      p->opt[posPrev].backPrev = backCur;
-      p->opt[posPrev].posPrev = cur;
-      cur = posPrev;
+      p->backRes = dist;
+      p->optCur = wr;
+      return len;
     }
+    
+    wr--;
+    p->opt[wr].dist = dist;
+    p->opt[wr].len = (UInt32)len;
   }
-  while (cur != 0);
-  *backRes = p->opt[0].backPrev;
-  p->optimumCurrentIndex  = p->opt[0].posPrev;
-  return p->optimumCurrentIndex;
 }
 
-#define LIT_PROBS(pos, prevByte) (p->litProbs + ((((pos) & p->lpMask) << p->lc) + ((prevByte) >> (8 - p->lc))) * (UInt32)0x300)
 
-static UInt32 GetOptimum(CLzmaEnc *p, UInt32 position, UInt32 *backRes)
+
+#define LIT_PROBS(pos, prevByte) \
+  (p->litProbs + (UInt32)3 * (((((pos) << 8) + (prevByte)) & p->lpMask) << p->lc))
+
+
+static unsigned GetOptimum(CLzmaEnc *p, UInt32 position)
 {
-  UInt32 lenEnd, cur;
-  UInt32 reps[LZMA_NUM_REPS], repLens[LZMA_NUM_REPS];
+  unsigned last, cur;
+  UInt32 reps[LZMA_NUM_REPS];
+  unsigned repLens[LZMA_NUM_REPS];
   UInt32 *matches;
 
   {
-
-  UInt32 numAvail, mainLen, numPairs, repMaxIndex, i, posState, len;
-  UInt32 matchPrice, repMatchPrice, normalMatchPrice;
-  const Byte *data;
-  Byte curByte, matchByte;
-
-  if (p->optimumEndIndex != p->optimumCurrentIndex)
-  {
-    const COptimal *opt = &p->opt[p->optimumCurrentIndex];
-    UInt32 lenRes = opt->posPrev - p->optimumCurrentIndex;
-    *backRes = opt->backPrev;
-    p->optimumCurrentIndex = opt->posPrev;
-    return lenRes;
-  }
-  p->optimumCurrentIndex = p->optimumEndIndex = 0;
-  
-  if (p->additionalOffset == 0)
-    mainLen = ReadMatchDistances(p, &numPairs);
-  else
-  {
-    mainLen = p->longestMatchLength;
-    numPairs = p->numPairs;
-  }
-
-  numAvail = p->numAvail;
-  if (numAvail < 2)
-  {
-    *backRes = (UInt32)(-1);
-    return 1;
-  }
-  if (numAvail > LZMA_MATCH_LEN_MAX)
-    numAvail = LZMA_MATCH_LEN_MAX;
-
-  data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
-  repMaxIndex = 0;
-  for (i = 0; i < LZMA_NUM_REPS; i++)
-  {
-    UInt32 lenTest;
-    const Byte *data2;
-    reps[i] = p->reps[i];
-    data2 = data - reps[i] - 1;
-    if (data[0] != data2[0] || data[1] != data2[1])
+    UInt32 numAvail;
+    unsigned numPairs, mainLen, repMaxIndex, i, posState;
+    UInt32 matchPrice, repMatchPrice;
+    const Byte *data;
+    Byte curByte, matchByte;
+    
+    p->optCur = p->optEnd = 0;
+    
+    if (p->additionalOffset == 0)
+      mainLen = ReadMatchDistances(p, &numPairs);
+    else
     {
-      repLens[i] = 0;
-      continue;
+      mainLen = p->longestMatchLen;
+      numPairs = p->numPairs;
     }
-    for (lenTest = 2; lenTest < numAvail && data[lenTest] == data2[lenTest]; lenTest++);
-    repLens[i] = lenTest;
-    if (lenTest > repLens[repMaxIndex])
-      repMaxIndex = i;
-  }
-  if (repLens[repMaxIndex] >= p->numFastBytes)
-  {
-    UInt32 lenRes;
-    *backRes = repMaxIndex;
-    lenRes = repLens[repMaxIndex];
-    MovePos(p, lenRes - 1);
-    return lenRes;
-  }
+    
+    numAvail = p->numAvail;
+    if (numAvail < 2)
+    {
+      p->backRes = MARK_LIT;
+      return 1;
+    }
+    if (numAvail > LZMA_MATCH_LEN_MAX)
+      numAvail = LZMA_MATCH_LEN_MAX;
+    
+    data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
+    repMaxIndex = 0;
+    
+    for (i = 0; i < LZMA_NUM_REPS; i++)
+    {
+      unsigned len;
+      const Byte *data2;
+      reps[i] = p->reps[i];
+      data2 = data - reps[i];
+      if (data[0] != data2[0] || data[1] != data2[1])
+      {
+        repLens[i] = 0;
+        continue;
+      }
+      for (len = 2; len < numAvail && data[len] == data2[len]; len++)
+      {}
+      repLens[i] = len;
+      if (len > repLens[repMaxIndex])
+        repMaxIndex = i;
+    }
+    
+    if (repLens[repMaxIndex] >= p->numFastBytes)
+    {
+      unsigned len;
+      p->backRes = (UInt32)repMaxIndex;
+      len = repLens[repMaxIndex];
+      MOVE_POS(p, len - 1)
+      return len;
+    }
+    
+    matches = p->matches;
+    
+    if (mainLen >= p->numFastBytes)
+    {
+      p->backRes = matches[(size_t)numPairs - 1] + LZMA_NUM_REPS;
+      MOVE_POS(p, mainLen - 1)
+      return mainLen;
+    }
+    
+    curByte = *data;
+    matchByte = *(data - reps[0]);
 
-  matches = p->matches;
-  if (mainLen >= p->numFastBytes)
-  {
-    *backRes = matches[(size_t)numPairs - 1] + LZMA_NUM_REPS;
-    MovePos(p, mainLen - 1);
-    return mainLen;
-  }
-  curByte = *data;
-  matchByte = *(data - (reps[0] + 1));
-
-  if (mainLen < 2 && curByte != matchByte && repLens[repMaxIndex] < 2)
-  {
-    *backRes = (UInt32)-1;
-    return 1;
-  }
-
-  p->opt[0].state = (CState)p->state;
-
-  posState = (position & p->pbMask);
-
-  {
-    const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));
-    p->opt[1].price = GET_PRICE_0(p->isMatch[p->state][posState]) +
-        (!IsCharState(p->state) ?
-          LitEnc_GetPriceMatched(probs, curByte, matchByte, p->ProbPrices) :
+    last = repLens[repMaxIndex];
+    if (last <= mainLen)
+      last = mainLen;
+    
+    if (last < 2 && curByte != matchByte)
+    {
+      p->backRes = MARK_LIT;
+      return 1;
+    }
+    
+    p->opt[0].state = (CState)p->state;
+    
+    posState = (position & p->pbMask);
+    
+    {
+      const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));
+      p->opt[1].price = GET_PRICE_0(p->isMatch[p->state][posState]) +
+        (!IsLitState(p->state) ?
+          LitEnc_Matched_GetPrice(probs, curByte, matchByte, p->ProbPrices) :
           LitEnc_GetPrice(probs, curByte, p->ProbPrices));
-  }
-
-  MakeAsChar(&p->opt[1]);
-
-  matchPrice = GET_PRICE_1(p->isMatch[p->state][posState]);
-  repMatchPrice = matchPrice + GET_PRICE_1(p->isRep[p->state]);
-
-  if (matchByte == curByte)
-  {
-    UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(p, p->state, posState);
-    if (shortRepPrice < p->opt[1].price)
-    {
-      p->opt[1].price = shortRepPrice;
-      MakeAsShortRep(&p->opt[1]);
     }
-  }
-  lenEnd = ((mainLen >= repLens[repMaxIndex]) ? mainLen : repLens[repMaxIndex]);
 
-  if (lenEnd < 2)
-  {
-    *backRes = p->opt[1].backPrev;
-    return 1;
-  }
-
-  p->opt[1].posPrev = 0;
-  for (i = 0; i < LZMA_NUM_REPS; i++)
-    p->opt[0].backs[i] = reps[i];
-
-  len = lenEnd;
-  do
-    p->opt[len--].price = kInfinityPrice;
-  while (len >= 2);
-
-  for (i = 0; i < LZMA_NUM_REPS; i++)
-  {
-    UInt32 repLen = repLens[i];
-    UInt32 price;
-    if (repLen < 2)
-      continue;
-    price = repMatchPrice + GetPureRepPrice(p, i, p->state, posState);
-    do
+    MakeAs_Lit(&p->opt[1]);
+    
+    matchPrice = GET_PRICE_1(p->isMatch[p->state][posState]);
+    repMatchPrice = matchPrice + GET_PRICE_1(p->isRep[p->state]);
+    
+    // 18.06
+    if (matchByte == curByte && repLens[0] == 0)
     {
-      UInt32 curAndLenPrice = price + p->repLenEnc.prices[posState][(size_t)repLen - 2];
-      COptimal *opt = &p->opt[repLen];
-      if (curAndLenPrice < opt->price)
+      UInt32 shortRepPrice = repMatchPrice + GetPrice_ShortRep(p, p->state, posState);
+      if (shortRepPrice < p->opt[1].price)
       {
-        opt->price = curAndLenPrice;
-        opt->posPrev = 0;
-        opt->backPrev = i;
-        opt->prev1IsChar = False;
+        p->opt[1].price = shortRepPrice;
+        MakeAs_ShortRep(&p->opt[1]);
+      }
+      if (last < 2)
+      {
+        p->backRes = p->opt[1].dist;
+        return 1;
       }
     }
-    while (--repLen >= 2);
-  }
-
-  normalMatchPrice = matchPrice + GET_PRICE_0(p->isRep[p->state]);
-
-  len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
-  if (len <= mainLen)
-  {
-    UInt32 offs = 0;
-    while (len > matches[offs])
-      offs += 2;
-    for (; ; len++)
+   
+    p->opt[1].len = 1;
+    
+    p->opt[0].reps[0] = reps[0];
+    p->opt[0].reps[1] = reps[1];
+    p->opt[0].reps[2] = reps[2];
+    p->opt[0].reps[3] = reps[3];
+    
+    // ---------- REP ----------
+    
+    for (i = 0; i < LZMA_NUM_REPS; i++)
     {
-      COptimal *opt;
-      UInt32 distance = matches[(size_t)offs + 1];
+      unsigned repLen = repLens[i];
+      UInt32 price;
+      if (repLen < 2)
+        continue;
+      price = repMatchPrice + GetPrice_PureRep(p, i, p->state, posState);
+      do
+      {
+        UInt32 price2 = price + GET_PRICE_LEN(&p->repLenEnc, posState, repLen);
+        COptimal *opt = &p->opt[repLen];
+        if (price2 < opt->price)
+        {
+          opt->price = price2;
+          opt->len = (UInt32)repLen;
+          opt->dist = (UInt32)i;
+          opt->extra = 0;
+        }
+      }
+      while (--repLen >= 2);
+    }
+    
+    
+    // ---------- MATCH ----------
+    {
+      unsigned len = repLens[0] + 1;
+      if (len <= mainLen)
+      {
+        unsigned offs = 0;
+        UInt32 normalMatchPrice = matchPrice + GET_PRICE_0(p->isRep[p->state]);
 
-      UInt32 curAndLenPrice = normalMatchPrice + p->lenEnc.prices[posState][(size_t)len - LZMA_MATCH_LEN_MIN];
-      UInt32 lenToPosState = GetLenToPosState(len);
-      if (distance < kNumFullDistances)
-        curAndLenPrice += p->distancesPrices[lenToPosState][distance];
-      else
-      {
-        UInt32 slot;
-        GetPosSlot2(distance, slot);
-        curAndLenPrice += p->alignPrices[distance & kAlignMask] + p->posSlotPrices[lenToPosState][slot];
-      }
-      opt = &p->opt[len];
-      if (curAndLenPrice < opt->price)
-      {
-        opt->price = curAndLenPrice;
-        opt->posPrev = 0;
-        opt->backPrev = distance + LZMA_NUM_REPS;
-        opt->prev1IsChar = False;
-      }
-      if (len == matches[offs])
-      {
-        offs += 2;
-        if (offs == numPairs)
-          break;
+        if (len < 2)
+          len = 2;
+        else
+          while (len > matches[offs])
+            offs += 2;
+    
+        for (; ; len++)
+        {
+          COptimal *opt;
+          UInt32 dist = matches[(size_t)offs + 1];
+          UInt32 price = normalMatchPrice + GET_PRICE_LEN(&p->lenEnc, posState, len);
+          unsigned lenToPosState = GetLenToPosState(len);
+       
+          if (dist < kNumFullDistances)
+            price += p->distancesPrices[lenToPosState][dist & (kNumFullDistances - 1)];
+          else
+          {
+            unsigned slot;
+            GetPosSlot2(dist, slot);
+            price += p->alignPrices[dist & kAlignMask];
+            price += p->posSlotPrices[lenToPosState][slot];
+          }
+          
+          opt = &p->opt[len];
+          
+          if (price < opt->price)
+          {
+            opt->price = price;
+            opt->len = (UInt32)len;
+            opt->dist = dist + LZMA_NUM_REPS;
+            opt->extra = 0;
+          }
+          
+          if (len == matches[offs])
+          {
+            offs += 2;
+            if (offs == numPairs)
+              break;
+          }
+        }
       }
     }
-  }
+    
 
-  cur = 0;
+    cur = 0;
 
     #ifdef SHOW_STAT2
     /* if (position >= 0) */
     {
       unsigned i;
       printf("\n pos = %4X", position);
-      for (i = cur; i <= lenEnd; i++)
+      for (i = cur; i <= last; i++)
       printf("\nprice[%4X] = %u", position - cur + i, p->opt[i].price);
     }
     #endif
-
   }
 
+
+  
+  // ---------- Optimal Parsing ----------
+
   for (;;)
   {
-    UInt32 numAvail;
-    UInt32 numAvailFull, newLen, numPairs, posPrev, state, posState, startLen;
-    UInt32 curPrice, curAnd1Price, matchPrice, repMatchPrice;
-    Bool nextIsChar;
+    unsigned numAvail;
+    UInt32 numAvailFull;
+    unsigned newLen, numPairs, prev, state, posState, startLen;
+    UInt32 litPrice, matchPrice, repMatchPrice;
+    BoolInt nextIsLit;
     Byte curByte, matchByte;
     const Byte *data;
-    COptimal *curOpt;
-    COptimal *nextOpt;
+    COptimal *curOpt, *nextOpt;
 
-    cur++;
-    if (cur == lenEnd)
-      return Backward(p, backRes, cur);
+    if (++cur == last)
+      break;
+    
+    // 18.06
+    if (cur >= kNumOpts - 64)
+    {
+      unsigned j, best;
+      UInt32 price = p->opt[cur].price;
+      best = cur;
+      for (j = cur + 1; j <= last; j++)
+      {
+        UInt32 price2 = p->opt[j].price;
+        if (price >= price2)
+        {
+          price = price2;
+          best = j;
+        }
+      }
+      {
+        unsigned delta = best - cur;
+        if (delta != 0)
+        {
+          MOVE_POS(p, delta);
+        }
+      }
+      cur = best;
+      break;
+    }
 
     newLen = ReadMatchDistances(p, &numPairs);
+    
     if (newLen >= p->numFastBytes)
     {
       p->numPairs = numPairs;
-      p->longestMatchLength = newLen;
-      return Backward(p, backRes, cur);
+      p->longestMatchLen = newLen;
+      break;
     }
-    position++;
+    
     curOpt = &p->opt[cur];
-    posPrev = curOpt->posPrev;
-    if (curOpt->prev1IsChar)
-    {
-      posPrev--;
-      if (curOpt->prev2)
-      {
-        state = p->opt[curOpt->posPrev2].state;
-        if (curOpt->backPrev2 < LZMA_NUM_REPS)
-          state = kRepNextStates[state];
-        else
-          state = kMatchNextStates[state];
-      }
-      else
-        state = p->opt[posPrev].state;
-      state = kLiteralNextStates[state];
-    }
-    else
-      state = p->opt[posPrev].state;
-    if (posPrev == cur - 1)
+
+    position++;
+
+    // we need that check here, if skip_items in p->opt are possible
+    /*
+    if (curOpt->price >= kInfinityPrice)
+      continue;
+    */
+
+    prev = cur - curOpt->len;
+
+    if (curOpt->len == 1)
     {
+      state = (unsigned)p->opt[prev].state;
       if (IsShortRep(curOpt))
         state = kShortRepNextStates[state];
       else
