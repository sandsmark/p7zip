diff --git a/C/XzDec.c b/C/XzDec.c
index 67216a5..395e83f 100644
--- a/C/XzDec.c
+++ b/C/XzDec.c
@@ -387,32 +387,128 @@ Hunk #11, a/C/XzDec.c SRes MixCoder_SetFromMethod(CMixCoder *p, unsigned coderIndex, UInt64 methodId)
   return BraState_SetFromMethod(sc, methodId, 0, p->alloc);
 }
 
-SRes MixCoder_Code(CMixCoder *p, Byte *dest, SizeT *destLen,
+
+static SRes MixCoder_ResetFromMethod(CMixCoder *p, unsigned coderIndex, UInt64 methodId, Byte *outBuf, size_t outBufSize)
+{
+  IStateCoder *sc = &p->coders[coderIndex];
+  switch (methodId)
+  {
+    case XZ_ID_LZMA2: return Lzma2State_ResetOutBuf(sc, outBuf, outBufSize);
+  }
+  return SZ_ERROR_UNSUPPORTED;
+}
+
+
+
+/*
+ if (destFinish) - then unpack data block is finished at (*destLen) position,
+                   and we can return data that were not processed by filter
+
+output (status) can be :
+  CODER_STATUS_NOT_FINISHED
+  CODER_STATUS_FINISHED_WITH_MARK
+  CODER_STATUS_NEEDS_MORE_INPUT - not implemented still
+*/
+
+static SRes MixCoder_Code(CMixCoder *p,
+    Byte *dest, SizeT *destLen, int destFinish,
     const Byte *src, SizeT *srcLen, int srcWasFinished,
-    ECoderFinishMode finishMode, ECoderStatus *status)
+    ECoderFinishMode finishMode)
 {
   SizeT destLenOrig = *destLen;
   SizeT srcLenOrig = *srcLen;
 
   *destLen = 0;
   *srcLen = 0;
-  *status = CODER_STATUS_NOT_FINISHED;
 
-  if (!p->buf)
+  if (p->wasFinished)
+    return p->res;
+  
+  p->status = CODER_STATUS_NOT_FINISHED;
+
+  // if (p->SingleBufMode)
+  if (p->outBuf)
   {
-    p->buf = (Byte *)ISzAlloc_Alloc(p->alloc, CODER_BUF_SIZE * (MIXCODER_NUM_FILTERS_MAX - 1));
-    if (!p->buf)
-      return SZ_ERROR_MEM;
+    SRes res;
+    SizeT destLen2, srcLen2;
+    int wasFinished;
+    
+    PRF_STR("------- MixCoder Single ----------");
+      
+    srcLen2 = srcLenOrig;
+    destLen2 = destLenOrig;
+    
+    {
+      IStateCoder *coder = &p->coders[0];
+      res = coder->Code2(coder->p, NULL, &destLen2, src, &srcLen2, srcWasFinished, finishMode,
+          // &wasFinished,
+          &p->status);
+      wasFinished = (p->status == CODER_STATUS_FINISHED_WITH_MARK);
+    }
+    
+    p->res = res;
+    
+    /*
+    if (wasFinished)
+      p->status = CODER_STATUS_FINISHED_WITH_MARK;
+    else
+    {
+      if (res == SZ_OK)
+        if (destLen2 != destLenOrig)
+          p->status = CODER_STATUS_NEEDS_MORE_INPUT;
+    }
+    */
+
+    
+    *srcLen = srcLen2;
+    src += srcLen2;
+    p->outWritten += destLen2;
+    
+    if (res != SZ_OK || srcWasFinished || wasFinished)
+      p->wasFinished = True;
+    
+    if (p->numCoders == 1)
+      *destLen = destLen2;
+    else if (p->wasFinished)
+    {
+      unsigned i;
+      size_t processed = p->outWritten;
+      
+      for (i = 1; i < p->numCoders; i++)
+      {
+        IStateCoder *coder = &p->coders[i];
+        processed = coder->Filter(coder->p, p->outBuf, processed);
+        if (wasFinished || (destFinish && p->outWritten == destLenOrig))
+          processed = p->outWritten;
+        PRF_STR_INT("filter", i);
+      }
+      *destLen = processed;
+    }
+    return res;
   }
 
+  PRF_STR("standard mix");
+
   if (p->numCoders != 1)
+  {
+    if (!p->buf)
+    {
+      p->buf = (Byte *)ISzAlloc_Alloc(p->alloc, CODER_BUF_SIZE * (MIXCODER_NUM_FILTERS_MAX - 1));
+      if (!p->buf)
+        return SZ_ERROR_MEM;
+    }
+    
     finishMode = CODER_FINISH_ANY;
+  }
 
   for (;;)
   {
-    Bool processed = False;
-    Bool allFinished = True;
+    BoolInt processed = False;
+    BoolInt allFinished = True;
+    SRes resMain = SZ_OK;
     unsigned i;
+
+    p->status = CODER_STATUS_NOT_FINISHED;
     /*
     if (p->numCoders == 1 && *destLen == destLenOrig && finishMode == LZMA_FINISH_ANY)
       break;
