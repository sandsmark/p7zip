diff --git a/C/LzmaEnc.c b/C/LzmaEnc.c
index 9b7e691..46a0db0 100644
--- a/C/LzmaEnc.c
+++ b/C/LzmaEnc.c
@@ -1838,123 +1838,253 @@ Hunk #28, a/C/LzmaEnc.c static SRes LzmaEnc_CodeOneBlock(CLzmaEnc *p, Bool useLimits, UInt32 maxPackSize
   }
 
   if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) != 0)
+  
   for (;;)
   {
-    UInt32 pos, len, posState;
-
+    UInt32 dist;
+    unsigned len, posState;
+    UInt32 range, ttt, newBound;
+    CLzmaProb *probs;
+  
     if (p->fastMode)
-      len = GetOptimumFast(p, &pos);
+      len = GetOptimumFast(p);
     else
-      len = GetOptimum(p, nowPos32, &pos);
+    {
+      unsigned oci = p->optCur;
+      if (p->optEnd == oci)
+        len = GetOptimum(p, nowPos32);
+      else
+      {
+        const COptimal *opt = &p->opt[oci];
+        len = opt->len;
+        p->backRes = opt->dist;
+        p->optCur = oci + 1;
+      }
+    }
+
+    posState = (unsigned)nowPos32 & p->pbMask;
+    range = p->rc.range;
+    probs = &p->isMatch[p->state][posState];
+    
+    RC_BIT_PRE(&p->rc, probs)
+    
+    dist = p->backRes;
 
     #ifdef SHOW_STAT2
-    printf("\n pos = %4X,   len = %u   pos = %u", nowPos32, len, pos);
+    printf("\n pos = %6X, len = %3u  pos = %6u", nowPos32, len, dist);
     #endif
 
-    posState = nowPos32 & p->pbMask;
-    if (len == 1 && pos == (UInt32)-1)
+    if (dist == MARK_LIT)
     {
       Byte curByte;
-      CLzmaProb *probs;
       const Byte *data;
+      unsigned state;
 
-      RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 0);
+      RC_BIT_0(&p->rc, probs);
+      p->rc.range = range;
       data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - p->additionalOffset;
-      curByte = *data;
       probs = LIT_PROBS(nowPos32, *(data - 1));
-      if (IsCharState(p->state))
+      curByte = *data;
+      state = p->state;
+      p->state = kLiteralNextStates[state];
+      if (IsLitState(state))
         LitEnc_Encode(&p->rc, probs, curByte);
       else
-        LitEnc_EncodeMatched(&p->rc, probs, curByte, *(data - p->reps[0] - 1));
-      p->state = kLiteralNextStates[p->state];
+        LitEnc_EncodeMatched(&p->rc, probs, curByte, *(data - p->reps[0]));
     }
     else
     {
-      RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 1);
-      if (pos < LZMA_NUM_REPS)
+      RC_BIT_1(&p->rc, probs);
+      probs = &p->isRep[p->state];
+      RC_BIT_PRE(&p->rc, probs)
+      
+      if (dist < LZMA_NUM_REPS)
       {
-        RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 1);
-        if (pos == 0)
+        RC_BIT_1(&p->rc, probs);
+        probs = &p->isRepG0[p->state];
+        RC_BIT_PRE(&p->rc, probs)
+        if (dist == 0)
         {
-          RangeEnc_EncodeBit(&p->rc, &p->isRepG0[p->state], 0);
-          RangeEnc_EncodeBit(&p->rc, &p->isRep0Long[p->state][posState], ((len == 1) ? 0 : 1));
+          RC_BIT_0(&p->rc, probs);
+          probs = &p->isRep0Long[p->state][posState];
+          RC_BIT_PRE(&p->rc, probs)
+          if (len != 1)
+          {
+            RC_BIT_1_BASE(&p->rc, probs);
+          }
+          else
+          {
+            RC_BIT_0_BASE(&p->rc, probs);
+            p->state = kShortRepNextStates[p->state];
+          }
         }
         else
         {
-          UInt32 distance = p->reps[pos];
-          RangeEnc_EncodeBit(&p->rc, &p->isRepG0[p->state], 1);
-          if (pos == 1)
-            RangeEnc_EncodeBit(&p->rc, &p->isRepG1[p->state], 0);
+          RC_BIT_1(&p->rc, probs);
+          probs = &p->isRepG1[p->state];
+          RC_BIT_PRE(&p->rc, probs)
+          if (dist == 1)
+          {
+            RC_BIT_0_BASE(&p->rc, probs);
+            dist = p->reps[1];
+          }
           else
           {
-            RangeEnc_EncodeBit(&p->rc, &p->isRepG1[p->state], 1);
-            RangeEnc_EncodeBit(&p->rc, &p->isRepG2[p->state], pos - 2);
-            if (pos == 3)
+            RC_BIT_1(&p->rc, probs);
+            probs = &p->isRepG2[p->state];
+            RC_BIT_PRE(&p->rc, probs)
+            if (dist == 2)
+            {
+              RC_BIT_0_BASE(&p->rc, probs);
+              dist = p->reps[2];
+            }
+            else
+            {
+              RC_BIT_1_BASE(&p->rc, probs);
+              dist = p->reps[3];
               p->reps[3] = p->reps[2];
+            }
             p->reps[2] = p->reps[1];
           }
           p->reps[1] = p->reps[0];
-          p->reps[0] = distance;
+          p->reps[0] = dist;
         }
-        if (len == 1)
-          p->state = kShortRepNextStates[p->state];
-        else
+
+        RC_NORM(&p->rc)
+
+        p->rc.range = range;
+
+        if (len != 1)
         {
-          LenEnc_Encode2(&p->repLenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
+          LenEnc_Encode(&p->repLenProbs, &p->rc, len - LZMA_MATCH_LEN_MIN, posState);
+          --p->repLenEncCounter;
           p->state = kRepNextStates[p->state];
         }
       }
       else
       {
-        UInt32 posSlot;
-        RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 0);
+        unsigned posSlot;
+        RC_BIT_0(&p->rc, probs);
+        p->rc.range = range;
         p->state = kMatchNextStates[p->state];
-        LenEnc_Encode2(&p->lenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
-        pos -= LZMA_NUM_REPS;
-        GetPosSlot(pos, posSlot);
-        RcTree_Encode(&p->rc, p->posSlotEncoder[GetLenToPosState(len)], kNumPosSlotBits, posSlot);
-        
-        if (posSlot >= kStartPosModelIndex)
-        {
-          UInt32 footerBits = ((posSlot >> 1) - 1);
-          UInt32 base = ((2 | (posSlot & 1)) << footerBits);
-          UInt32 posReduced = pos - base;
 
-          if (posSlot < kEndPosModelIndex)
-            RcTree_ReverseEncode(&p->rc, p->posEncoders + base - posSlot - 1, footerBits, posReduced);
-          else
-          {
-            RangeEnc_EncodeDirectBits(&p->rc, posReduced >> kNumAlignBits, footerBits - kNumAlignBits);
-            RcTree_ReverseEncode(&p->rc, p->posAlignEncoder, kNumAlignBits, posReduced & kAlignMask);
-            p->alignPriceCount++;
-          }
-        }
+        LenEnc_Encode(&p->lenProbs, &p->rc, len - LZMA_MATCH_LEN_MIN, posState);
+        // --p->lenEnc.counter;
+
+        dist -= LZMA_NUM_REPS;
         p->reps[3] = p->reps[2];
         p->reps[2] = p->reps[1];
         p->reps[1] = p->reps[0];
-        p->reps[0] = pos;
+        p->reps[0] = dist + 1;
+        
         p->matchPriceCount++;
+        GetPosSlot(dist, posSlot);
+        // RcTree_Encode_PosSlot(&p->rc, p->posSlotEncoder[GetLenToPosState(len)], posSlot);
+        {
+          UInt32 sym = (UInt32)posSlot + (1 << kNumPosSlotBits);
+          range = p->rc.range;
+          probs = p->posSlotEncoder[GetLenToPosState(len)];
+          do
+          {
+            CLzmaProb *prob = probs + (sym >> kNumPosSlotBits);
+            UInt32 bit = (sym >> (kNumPosSlotBits - 1)) & 1;
+            sym <<= 1;
+            RC_BIT(&p->rc, prob, bit);
+          }
+          while (sym < (1 << kNumPosSlotBits * 2));
+          p->rc.range = range;
+        }
+        
+        if (dist >= kStartPosModelIndex)
+        {
+          unsigned footerBits = ((posSlot >> 1) - 1);
+
+          if (dist < kNumFullDistances)
+          {
+            unsigned base = ((2 | (posSlot & 1)) << footerBits);
+            RcTree_ReverseEncode(&p->rc, p->posEncoders + base, footerBits, (unsigned)(dist /* - base */));
+          }
+          else
+          {
+            UInt32 pos2 = (dist | 0xF) << (32 - footerBits);
+            range = p->rc.range;
+            // RangeEnc_EncodeDirectBits(&p->rc, posReduced >> kNumAlignBits, footerBits - kNumAlignBits);
+            /*
+            do
+            {
+              range >>= 1;
+              p->rc.low += range & (0 - ((dist >> --footerBits) & 1));
+              RC_NORM(&p->rc)
+            }
+            while (footerBits > kNumAlignBits);
+            */
+            do
+            {
+              range >>= 1;
+              p->rc.low += range & (0 - (pos2 >> 31));
+              pos2 += pos2;
+              RC_NORM(&p->rc)
+            }
+            while (pos2 != 0xF0000000);
+
+
+            // RcTree_ReverseEncode(&p->rc, p->posAlignEncoder, kNumAlignBits, posReduced & kAlignMask);
+
+            {
+              unsigned m = 1;
+              unsigned bit;
+              bit = dist & 1; dist >>= 1; RC_BIT(&p->rc, p->posAlignEncoder + m, bit); m = (m << 1) + bit;
+              bit = dist & 1; dist >>= 1; RC_BIT(&p->rc, p->posAlignEncoder + m, bit); m = (m << 1) + bit;
+              bit = dist & 1; dist >>= 1; RC_BIT(&p->rc, p->posAlignEncoder + m, bit); m = (m << 1) + bit;
+              bit = dist & 1;             RC_BIT(&p->rc, p->posAlignEncoder + m, bit);
+              p->rc.range = range;
+              // p->alignPriceCount++;
+            }
+          }
+        }
       }
     }
+
+    nowPos32 += (UInt32)len;
     p->additionalOffset -= len;
-    nowPos32 += len;
+    
     if (p->additionalOffset == 0)
     {
       UInt32 processed;
+
       if (!p->fastMode)
       {
-        if (p->matchPriceCount >= (1 << 7))
-          FillDistancesPrices(p);
-        if (p->alignPriceCount >= kAlignTableSize)
+        /*
+        if (p->alignPriceCount >= 16) // kAlignTableSize
           FillAlignPrices(p);
+        if (p->matchPriceCount >= 128)
+          FillDistancesPrices(p);
+        if (p->lenEnc.counter <= 0)
+          LenPriceEnc_UpdateTables(&p->lenEnc, 1 << p->pb, &p->lenProbs, p->ProbPrices);
+        */
+        if (p->matchPriceCount >= 64)
+        {
+          FillAlignPrices(p);
+          // { int y; for (y = 0; y < 100; y++) {
+          FillDistancesPrices(p);
+          // }}
+          LenPriceEnc_UpdateTables(&p->lenEnc, 1 << p->pb, &p->lenProbs, p->ProbPrices);
+        }
+        if (p->repLenEncCounter <= 0)
+        {
+          p->repLenEncCounter = REP_LEN_COUNT;
+          LenPriceEnc_UpdateTables(&p->repLenEnc, 1 << p->pb, &p->repLenProbs, p->ProbPrices);
+        }
       }
+    
       if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) == 0)
         break;
       processed = nowPos32 - startPos32;
-      if (useLimits)
+      
+      if (maxPackSize)
       {
-        if (processed + kNumOpts + 300 >= maxUnpackSize ||
-            RangeEnc_GetProcessed(&p->rc) + kNumOpts * 2 >= maxPackSize)
+        if (processed + kNumOpts + 300 >= maxUnpackSize
+            || RangeEnc_GetProcessed_sizet(&p->rc) + kPackReserve >= maxPackSize)
           break;
       }
       else if (processed >= (1 << 17))
