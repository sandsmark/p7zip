diff --git a/CPP/7zip/Compress/ShrinkDecoder.cpp b/CPP/7zip/Compress/ShrinkDecoder.cpp
index bd7c246..41f0e35 100644
--- a/CPP/7zip/Compress/ShrinkDecoder.cpp
+++ b/CPP/7zip/Compress/ShrinkDecoder.cpp
@@ -137,27 +137,22 @@ Hunk #5, a/CPP/7zip/Compress/ShrinkDecoder.cpp HRESULT CDecoder::CodeReal(ISequentialInStream *inStream, ISequentialOutStream *
     bool needPrev = false;
     if (head < kNumItems && lastSym >= 0)
     {
-      while (head < kNumItems && _parents[head] != kNumItems)
+      while (head < kNumItems && _parents[head] != kEmpty)
         head++;
       if (head < kNumItems)
       {
-        if (head == (unsigned)lastSym)
-        {
-          // we need to fix the code for that case
-          // _parents[head] is not allowed to link to itself
-          res = E_NOTIMPL;
-          break;
-        }
+        /*
+        if (head == lastSym), it updates Orphan to self-linked Orphan and creates two problems:
+            1) we must check _stack[i++] overflow in code that walks tree nodes.
+            2) self-linked node can not be removed. So such self-linked nodes can occupy all _parents items.
+        */
         needPrev = true;
         _parents[head] = (UInt16)lastSym;
-        _suffixes[head] = (Byte)lastChar2;
+        _suffixes[head] = (Byte)lastChar;
         head++;
       }
     }
 
-    if (_parents[sym] == kNumItems)
-      break;
-
     lastSym = sym;
     unsigned cur = sym;
     unsigned i = 0;
