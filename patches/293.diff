diff --git a/C/Xz.h b/C/Xz.h
index 285fb55..544ee18 100644
--- a/C/Xz.h
+++ b/C/Xz.h
@@ -225,16 +225,64 @@ Hunk #8, a/C/Xz.h typedef struct
   CXzCheck check;
   CSha256 sha;
 
+  BoolInt parseMode;
+  BoolInt headerParsedOk;
+  BoolInt decodeToStreamSignature;
   unsigned decodeOnlyOneBlock;
 
+  Byte *outBuf;
+  size_t outBufSize;
+  size_t outDataWritten; // the size of data in (outBuf) that were fully unpacked
+
   Byte shaDigest[SHA256_DIGEST_SIZE];
   Byte buf[XZ_BLOCK_HEADER_SIZE_MAX];
 } CXzUnpacker;
 
+/* alloc : aligned for cache line allocation is better */
 void XzUnpacker_Construct(CXzUnpacker *p, ISzAllocPtr alloc);
 void XzUnpacker_Init(CXzUnpacker *p);
+void XzUnpacker_SetOutBuf(CXzUnpacker *p, Byte *outBuf, size_t outBufSize);
 void XzUnpacker_Free(CXzUnpacker *p);
 
+/*
+  XzUnpacker
+  The sequence for decoding functions:
+  {
+    XzUnpacker_Construct()
+    [Decoding_Calls]
+    XzUnpacker_Free()
+  }
+
+  [Decoding_Calls]
+
+  There are 3 types of interfaces for [Decoding_Calls] calls:
+
+  Interface-1 : Partial output buffers:
+    {
+      XzUnpacker_Init()
+      for()
+        XzUnpacker_Code();
+    }
+    
+  Interface-2 : Direct output buffer:
+    Use it, if you know exact size of decoded data, and you need
+    whole xz unpacked data in one output buffer.
+    xz unpacker doesn't allocate additional buffer for lzma2 dictionary in that mode.
+    {
+      XzUnpacker_Init()
+      XzUnpacker_SetOutBufMode(); // to set output buffer and size
+      for()
+        XzUnpacker_Code(); // (dest = NULL) in XzUnpacker_Code()
+    }
+
+  Interface-3 : Direct output buffer : One call full decoding
+    It unpacks whole input buffer to output buffer in one call.
+    It uses Interface-2 internally.
+    {
+      XzUnpacker_CodeFull()
+    }
+*/
+
 /*
 finishMode:
   It has meaning only if the decoding reaches output limit (*destLen).
