diff --git a/C/LzmaEnc.c b/C/LzmaEnc.c
index 9b7e691..46a0db0 100644
--- a/C/LzmaEnc.c
+++ b/C/LzmaEnc.c
@@ -2046,41 +2046,47 @@ Hunk #32, a/C/LzmaEnc.c void LzmaEnc_Init(CLzmaEnc *p)
     p->isRepG2[i] = kProbInitValue;
   }
 
-  {
-    UInt32 num = (UInt32)0x300 << (p->lp + p->lc);
-    CLzmaProb *probs = p->litProbs;
-    for (i = 0; i < num; i++)
-      probs[i] = kProbInitValue;
-  }
-
   {
     for (i = 0; i < kNumLenToPosStates; i++)
     {
       CLzmaProb *probs = p->posSlotEncoder[i];
-      UInt32 j;
+      unsigned j;
       for (j = 0; j < (1 << kNumPosSlotBits); j++)
         probs[j] = kProbInitValue;
     }
   }
   {
-    for (i = 0; i < kNumFullDistances - kEndPosModelIndex; i++)
+    for (i = 0; i < kNumFullDistances; i++)
       p->posEncoders[i] = kProbInitValue;
   }
 
-  LenEnc_Init(&p->lenEnc.p);
-  LenEnc_Init(&p->repLenEnc.p);
+  {
+    UInt32 num = (UInt32)0x300 << (p->lp + p->lc);
+    UInt32 k;
+    CLzmaProb *probs = p->litProbs;
+    for (k = 0; k < num; k++)
+      probs[k] = kProbInitValue;
+  }
 
-  for (i = 0; i < (1 << kNumAlignBits); i++)
-    p->posAlignEncoder[i] = kProbInitValue;
 
-  p->optimumEndIndex = 0;
-  p->optimumCurrentIndex = 0;
+  LenEnc_Init(&p->lenProbs);
+  LenEnc_Init(&p->repLenProbs);
+
+  p->optEnd = 0;
+  p->optCur = 0;
+
+  {
+    for (i = 0; i < kNumOpts; i++)
+      p->opt[i].price = kInfinityPrice;
+  }
+
   p->additionalOffset = 0;
 
   p->pbMask = (1 << p->pb) - 1;
-  p->lpMask = (1 << p->lp) - 1;
+  p->lpMask = ((UInt32)0x100 << p->lp) - ((unsigned)0x100 >> p->lc);
 }
 
+
 void LzmaEnc_InitPrices(CLzmaEnc *p)
 {
   if (!p->fastMode)
