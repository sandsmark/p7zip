diff --git a/CPP/7zip/Compress/Lzma2Decoder.cpp b/CPP/7zip/Compress/Lzma2Decoder.cpp
index 98af203..653fe2d 100644
--- a/CPP/7zip/Compress/Lzma2Decoder.cpp
+++ b/CPP/7zip/Compress/Lzma2Decoder.cpp
@@ -88,6 +88,137 @@ Hunk #2, a/CPP/7zip/Compress/Lzma2Decoder.cpp STDMETHODIMP CDecoder::SetFinishMode(UInt32 finishMode)
 }
 
 
+
+#ifndef _7ZIP_ST
+
+static UInt64 Get_ExpectedBlockSize_From_Dict(UInt32 dictSize)
+{
+  const UInt32 kMinSize = (UInt32)1 << 20;
+  const UInt32 kMaxSize = (UInt32)1 << 28;
+  UInt64 blockSize = (UInt64)dictSize << 2;
+  if (blockSize < kMinSize) blockSize = kMinSize;
+  if (blockSize > kMaxSize) blockSize = kMaxSize;
+  if (blockSize < dictSize) blockSize = dictSize;
+  blockSize += (kMinSize - 1);
+  blockSize &= ~(UInt64)(kMinSize - 1);
+  return blockSize;
+}
+
+#define LZMA2_DIC_SIZE_FROM_PROP_FULL(p) ((p) == 40 ? 0xFFFFFFFF : (((UInt32)2 | ((p) & 1)) << ((p) / 2 + 11)))
+
+#endif
+
+#define RET_IF_WRAP_ERROR_CONFIRMED(wrapRes, sRes, sResErrorCode) \
+  if (wrapRes != S_OK && sRes == sResErrorCode) return wrapRes;
+
+#define RET_IF_WRAP_ERROR(wrapRes, sRes, sResErrorCode) \
+  if (wrapRes != S_OK /* && (sRes == SZ_OK || sRes == sResErrorCode) */) return wrapRes;
+
+STDMETHODIMP CDecoder::Code(ISequentialInStream *inStream, ISequentialOutStream *outStream,
+    const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress)
+{
+  _inProcessed = 0;
+
+  if (!_dec)
+  {
+    _dec = Lzma2DecMt_Create(
+      // &g_AlignedAlloc,
+      &g_Alloc,
+      &g_MidAlloc);
+    if (!_dec)
+      return E_OUTOFMEMORY;
+  }
+
+  CLzma2DecMtProps props;
+  Lzma2DecMtProps_Init(&props);
+
+  props.inBufSize_ST = _inBufSize;
+  props.outStep_ST = _outStep;
+
+  #ifndef _7ZIP_ST
+  {
+    props.numThreads = 1;
+    UInt32 numThreads = _numThreads;
+
+    if (_tryMt && numThreads >= 1)
+    {
+      UInt64 useLimit = _memUsage;
+      UInt32 dictSize = LZMA2_DIC_SIZE_FROM_PROP_FULL(_prop);
+      UInt64 expectedBlockSize64 = Get_ExpectedBlockSize_From_Dict(dictSize);
+      size_t expectedBlockSize = (size_t)expectedBlockSize64;
+      size_t inBlockMax = expectedBlockSize + expectedBlockSize / 16;
+      if (expectedBlockSize == expectedBlockSize64 && inBlockMax >= expectedBlockSize)
+      {
+        props.outBlockMax = expectedBlockSize;
+        props.inBlockMax = inBlockMax;
+        const size_t kOverheadSize = props.inBufSize_MT + (1 << 16);
+        UInt64 okThreads = useLimit / (props.outBlockMax + props.inBlockMax + kOverheadSize);
+        if (numThreads > okThreads)
+          numThreads = (UInt32)okThreads;
+        if (numThreads == 0)
+          numThreads = 1;
+        props.numThreads = numThreads;
+      }
+    }
+  }
+  #endif
+
+  CSeqInStreamWrap inWrap;
+  CSeqOutStreamWrap outWrap;
+  CCompressProgressWrap progressWrap;
+
+  inWrap.Init(inStream);
+  outWrap.Init(outStream);
+  progressWrap.Init(progress);
+
+  SRes res;
+
+  UInt64 inProcessed = 0;
+  int isMT = False;
+
+  #ifndef _7ZIP_ST
+  isMT = _tryMt;
+  #endif
+
+  // UInt64 cpuTicks = GetCpuTicks();
+
+  res = Lzma2DecMt_Decode(_dec, _prop, &props,
+      &outWrap.vt, outSize, _finishMode,
+      &inWrap.vt,
+      &inProcessed,
+      &isMT,
+      progress ? &progressWrap.vt : NULL);
+
+  /*
+  cpuTicks = GetCpuTicks() - cpuTicks;
+  printf("\n             ticks = %10I64u\n", cpuTicks / 1000000);
+  */
+
+
+  #ifndef _7ZIP_ST
+  /* we reset _tryMt, only if p->props.numThreads was changed */
+  if (props.numThreads > 1)
+    _tryMt = isMT;
+  #endif
+
+  _inProcessed = inProcessed;
+
+  RET_IF_WRAP_ERROR(progressWrap.Res, res, SZ_ERROR_PROGRESS)
+  RET_IF_WRAP_ERROR(outWrap.Res, res, SZ_ERROR_WRITE)
+  RET_IF_WRAP_ERROR_CONFIRMED(inWrap.Res, res, SZ_ERROR_READ)
+
+  if (res == SZ_OK && _finishMode)
+  {
+    if (inSize && *inSize != inProcessed)
+      res = SZ_ERROR_DATA;
+    if (outSize && *outSize != outWrap.Processed)
+      res = SZ_ERROR_DATA;
+  }
+
+  return SResToHRESULT(res);
+}
+
+
 STDMETHODIMP CDecoder::GetInStreamProcessedSize(UInt64 *value)
 {
   *value = _inProcessed;
