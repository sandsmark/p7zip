diff --git a/C/Xz.h b/C/Xz.h
index 285fb55..544ee18 100644
--- a/C/Xz.h
+++ b/C/Xz.h
@@ -264,15 +264,23 @@ Hunk #9, a/C/Xz.h void XzUnpacker_Free(CXzUnpacker *p);
 
 
 SRes XzUnpacker_Code(CXzUnpacker *p, Byte *dest, SizeT *destLen,
-    const Byte *src, SizeT *srcLen, ECoderFinishMode finishMode,
-    ECoderStatus *status);
+    const Byte *src, SizeT *srcLen, int srcFinished,
+    ECoderFinishMode finishMode, ECoderStatus *status);
 
-Bool XzUnpacker_IsStreamWasFinished(const CXzUnpacker *p);
+SRes XzUnpacker_CodeFull(CXzUnpacker *p, Byte *dest, SizeT *destLen,
+    const Byte *src, SizeT *srcLen,
+    ECoderFinishMode finishMode, ECoderStatus *status);
+
+BoolInt XzUnpacker_IsStreamWasFinished(const CXzUnpacker *p);
 
 /*
-Call XzUnpacker_GetExtraSize after XzUnpacker_Code function to detect real size of
-xz stream in two cases:
-XzUnpacker_Code() returns:
+XzUnpacker_GetExtraSize() returns then number of uncofirmed bytes,
+ if it's in (XZ_STATE_STREAM_HEADER) state or in (XZ_STATE_STREAM_PADDING) state.
+These bytes can be some bytes after xz archive, or
+it can be start of new xz stream.
+ 
+Call XzUnpacker_GetExtraSize() after XzUnpacker_Code() function to detect real size of
+xz stream in two cases, if XzUnpacker_Code() returns:
   res == SZ_OK && status == CODER_STATUS_NEEDS_MORE_INPUT
   res == SZ_ERROR_NO_ARCHIVE
 */
