diff --git a/C/LzmaEnc.c b/C/LzmaEnc.c
index 9b7e691..46a0db0 100644
--- a/C/LzmaEnc.c
+++ b/C/LzmaEnc.c
@@ -1244,357 +1244,499 @@ Hunk #21, a/C/LzmaEnc.c static UInt32 GetOptimum(CLzmaEnc *p, UInt32 position, UInt32 *backRes)
     }
     else
     {
-      UInt32 pos;
       const COptimal *prevOpt;
-      if (curOpt->prev1IsChar && curOpt->prev2)
+      UInt32 b0;
+      UInt32 dist = curOpt->dist;
+
+      if (curOpt->extra)
       {
-        posPrev = curOpt->posPrev2;
-        pos = curOpt->backPrev2;
-        state = kRepNextStates[state];
+        prev -= (unsigned)curOpt->extra;
+        state = kState_RepAfterLit;
+        if (curOpt->extra == 1)
+          state = (dist < LZMA_NUM_REPS ? kState_RepAfterLit : kState_MatchAfterLit);
       }
       else
       {
-        pos = curOpt->backPrev;
-        if (pos < LZMA_NUM_REPS)
+        state = (unsigned)p->opt[prev].state;
+        if (dist < LZMA_NUM_REPS)
           state = kRepNextStates[state];
         else
           state = kMatchNextStates[state];
       }
-      prevOpt = &p->opt[posPrev];
-      if (pos < LZMA_NUM_REPS)
+
+      prevOpt = &p->opt[prev];
+      b0 = prevOpt->reps[0];
+
+      if (dist < LZMA_NUM_REPS)
       {
-        UInt32 i;
-        reps[0] = prevOpt->backs[pos];
-        for (i = 1; i <= pos; i++)
-          reps[i] = prevOpt->backs[(size_t)i - 1];
-        for (; i < LZMA_NUM_REPS; i++)
-          reps[i] = prevOpt->backs[i];
+        if (dist == 0)
+        {
+          reps[0] = b0;
+          reps[1] = prevOpt->reps[1];
+          reps[2] = prevOpt->reps[2];
+          reps[3] = prevOpt->reps[3];
+        }
+        else
+        {
+          reps[1] = b0;
+          b0 = prevOpt->reps[1];
+          if (dist == 1)
+          {
+            reps[0] = b0;
+            reps[2] = prevOpt->reps[2];
+            reps[3] = prevOpt->reps[3];
+          }
+          else
+          {
+            reps[2] = b0;
+            reps[0] = prevOpt->reps[dist];
+            reps[3] = prevOpt->reps[dist ^ 1];
+          }
+        }
       }
       else
       {
-        UInt32 i;
-        reps[0] = (pos - LZMA_NUM_REPS);
-        for (i = 1; i < LZMA_NUM_REPS; i++)
-          reps[i] = prevOpt->backs[(size_t)i - 1];
+        reps[0] = (dist - LZMA_NUM_REPS + 1);
+        reps[1] = b0;
+        reps[2] = prevOpt->reps[1];
+        reps[3] = prevOpt->reps[2];
       }
     }
+    
     curOpt->state = (CState)state;
+    curOpt->reps[0] = reps[0];
+    curOpt->reps[1] = reps[1];
+    curOpt->reps[2] = reps[2];
+    curOpt->reps[3] = reps[3];
 
-    curOpt->backs[0] = reps[0];
-    curOpt->backs[1] = reps[1];
-    curOpt->backs[2] = reps[2];
-    curOpt->backs[3] = reps[3];
-
-    curPrice = curOpt->price;
-    nextIsChar = False;
     data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
     curByte = *data;
-    matchByte = *(data - (reps[0] + 1));
+    matchByte = *(data - reps[0]);
 
     posState = (position & p->pbMask);
 
-    curAnd1Price = curPrice + GET_PRICE_0(p->isMatch[state][posState]);
+    /*
+    The order of Price checks:
+       <  LIT
+       <= SHORT_REP
+       <  LIT : REP_0
+       <  REP    [ : LIT : REP_0 ]
+       <  MATCH  [ : LIT : REP_0 ]
+    */
+
     {
-      const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));
-      curAnd1Price +=
-        (!IsCharState(state) ?
-          LitEnc_GetPriceMatched(probs, curByte, matchByte, p->ProbPrices) :
-          LitEnc_GetPrice(probs, curByte, p->ProbPrices));
+      UInt32 curPrice = curOpt->price;
+      unsigned prob = p->isMatch[state][posState];
+      matchPrice = curPrice + GET_PRICE_1(prob);
+      litPrice = curPrice + GET_PRICE_0(prob);
     }
 
     nextOpt = &p->opt[(size_t)cur + 1];
+    nextIsLit = False;
 
-    if (curAnd1Price < nextOpt->price)
+    // here we can allow skip_items in p->opt, if we don't check (nextOpt->price < kInfinityPrice)
+    // 18.new.06
+    if ((nextOpt->price < kInfinityPrice
+        // && !IsLitState(state)
+        && matchByte == curByte)
+        || litPrice > nextOpt->price
+        )
+      litPrice = 0;
+    else
     {
-      nextOpt->price = curAnd1Price;
-      nextOpt->posPrev = cur;
-      MakeAsChar(nextOpt);
-      nextIsChar = True;
-    }
-
-    matchPrice = curPrice + GET_PRICE_1(p->isMatch[state][posState]);
-    repMatchPrice = matchPrice + GET_PRICE_1(p->isRep[state]);
-    
-    if (matchByte == curByte && !(nextOpt->posPrev < cur && nextOpt->backPrev == 0))
-    {
-      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(p, state, posState);
-      if (shortRepPrice <= nextOpt->price)
+      const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));
+      litPrice += (!IsLitState(state) ?
+          LitEnc_Matched_GetPrice(probs, curByte, matchByte, p->ProbPrices) :
+          LitEnc_GetPrice(probs, curByte, p->ProbPrices));
+      
+      if (litPrice < nextOpt->price)
       {
-        nextOpt->price = shortRepPrice;
-        nextOpt->posPrev = cur;
-        MakeAsShortRep(nextOpt);
-        nextIsChar = True;
+        nextOpt->price = litPrice;
+        nextOpt->len = 1;
+        MakeAs_Lit(nextOpt);
+        nextIsLit = True;
       }
     }
+
+    repMatchPrice = matchPrice + GET_PRICE_1(p->isRep[state]);
+    
     numAvailFull = p->numAvail;
     {
-      UInt32 temp = kNumOpts - 1 - cur;
-      if (temp < numAvailFull)
-        numAvailFull = temp;
+      unsigned temp = kNumOpts - 1 - cur;
+      if (numAvailFull > temp)
+        numAvailFull = (UInt32)temp;
     }
 
+    // 18.06
+    // ---------- SHORT_REP ----------
+    if (IsLitState(state)) // 18.new
+    if (matchByte == curByte)
+    if (repMatchPrice < nextOpt->price) // 18.new
+    // if (numAvailFull < 2 || data[1] != *(data - reps[0] + 1))
+    if (
+        // nextOpt->price >= kInfinityPrice ||
+        nextOpt->len < 2   // we can check nextOpt->len, if skip items are not allowed in p->opt
+        || (nextOpt->dist != 0
+            // && nextOpt->extra <= 1 // 17.old
+            )
+        )
+    {
+      UInt32 shortRepPrice = repMatchPrice + GetPrice_ShortRep(p, state, posState);
+      // if (shortRepPrice <= nextOpt->price) // 17.old
+      if (shortRepPrice < nextOpt->price)  // 18.new
+      {
+        nextOpt->price = shortRepPrice;
+        nextOpt->len = 1;
+        MakeAs_ShortRep(nextOpt);
+        nextIsLit = False;
+      }
+    }
+    
     if (numAvailFull < 2)
       continue;
     numAvail = (numAvailFull <= p->numFastBytes ? numAvailFull : p->numFastBytes);
 
-    if (!nextIsChar && matchByte != curByte) /* speed optimization */
-    {
-      /* try Literal + rep0 */
-      UInt32 temp;
-      UInt32 lenTest2;
-      const Byte *data2 = data - reps[0] - 1;
-      UInt32 limit = p->numFastBytes + 1;
-      if (limit > numAvailFull)
-        limit = numAvailFull;
+    // numAvail <= p->numFastBytes
 
-      for (temp = 1; temp < limit && data[temp] == data2[temp]; temp++);
-      lenTest2 = temp - 1;
-      if (lenTest2 >= 2)
+    // ---------- LIT : REP_0 ----------
+
+    if (!nextIsLit
+        && litPrice != 0 // 18.new
+        && matchByte != curByte
+        && numAvailFull > 2)
+    {
+      const Byte *data2 = data - reps[0];
+      if (data[1] == data2[1] && data[2] == data2[2])
       {
-        UInt32 state2 = kLiteralNextStates[state];
-        UInt32 posStateNext = (position + 1) & p->pbMask;
-        UInt32 nextRepMatchPrice = curAnd1Price +
-            GET_PRICE_1(p->isMatch[state2][posStateNext]) +
-            GET_PRICE_1(p->isRep[state2]);
-        /* for (; lenTest2 >= 2; lenTest2--) */
+        unsigned len;
+        unsigned limit = p->numFastBytes + 1;
+        if (limit > numAvailFull)
+          limit = numAvailFull;
+        for (len = 3; len < limit && data[len] == data2[len]; len++)
+        {}
+        
         {
-          UInt32 curAndLenPrice;
-          COptimal *opt;
-          UInt32 offset = cur + 1 + lenTest2;
-          while (lenEnd < offset)
-            p->opt[++lenEnd].price = kInfinityPrice;
-          curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
-          opt = &p->opt[offset];
-          if (curAndLenPrice < opt->price)
+          unsigned state2 = kLiteralNextStates[state];
+          unsigned posState2 = (position + 1) & p->pbMask;
+          UInt32 price = litPrice + GetPrice_Rep_0(p, state2, posState2);
           {
-            opt->price = curAndLenPrice;
-            opt->posPrev = cur + 1;
-            opt->backPrev = 0;
-            opt->prev1IsChar = True;
-            opt->prev2 = False;
+            unsigned offset = cur + len;
+
+            if (last < offset)
+              last = offset;
+          
+            // do
+            {
+              UInt32 price2;
+              COptimal *opt;
+              len--;
+              // price2 = price + GetPrice_Len_Rep_0(p, len, state2, posState2);
+              price2 = price + GET_PRICE_LEN(&p->repLenEnc, posState2, len);
+
+              opt = &p->opt[offset];
+              // offset--;
+              if (price2 < opt->price)
+              {
+                opt->price = price2;
+                opt->len = (UInt32)len;
+                opt->dist = 0;
+                opt->extra = 1;
+              }
+            }
+            // while (len >= 3);
           }
         }
       }
     }
     
     startLen = 2; /* speed optimization */
+
     {
-    UInt32 repIndex;
-    for (repIndex = 0; repIndex < LZMA_NUM_REPS; repIndex++)
-    {
-      UInt32 lenTest;
-      UInt32 lenTestTemp;
-      UInt32 price;
-      const Byte *data2 = data - reps[repIndex] - 1;
-      if (data[0] != data2[0] || data[1] != data2[1])
-        continue;
-      for (lenTest = 2; lenTest < numAvail && data[lenTest] == data2[lenTest]; lenTest++);
-      while (lenEnd < cur + lenTest)
-        p->opt[++lenEnd].price = kInfinityPrice;
-      lenTestTemp = lenTest;
-      price = repMatchPrice + GetPureRepPrice(p, repIndex, state, posState);
-      do
+      // ---------- REP ----------
+      unsigned repIndex = 0; // 17.old
+      // unsigned repIndex = IsLitState(state) ? 0 : 1; // 18.notused
+      for (; repIndex < LZMA_NUM_REPS; repIndex++)
       {
-        UInt32 curAndLenPrice = price + p->repLenEnc.prices[posState][(size_t)lenTest - 2];
-        COptimal *opt = &p->opt[cur + lenTest];
-        if (curAndLenPrice < opt->price)
-        {
-          opt->price = curAndLenPrice;
-          opt->posPrev = cur;
-          opt->backPrev = repIndex;
-          opt->prev1IsChar = False;
-        }
-      }
-      while (--lenTest >= 2);
-      lenTest = lenTestTemp;
-      
-      if (repIndex == 0)
-        startLen = lenTest + 1;
+        unsigned len;
+        UInt32 price;
+        const Byte *data2 = data - reps[repIndex];
+        if (data[0] != data2[0] || data[1] != data2[1])
+          continue;
         
-      /* if (_maxMode) */
+        for (len = 2; len < numAvail && data[len] == data2[len]; len++)
+        {}
+        
+        // if (len < startLen) continue; // 18.new: speed optimization
+
         {
-          UInt32 lenTest2 = lenTest + 1;
-          UInt32 limit = lenTest2 + p->numFastBytes;
-          if (limit > numAvailFull)
-            limit = numAvailFull;
-          for (; lenTest2 < limit && data[lenTest2] == data2[lenTest2]; lenTest2++);
-          lenTest2 -= lenTest + 1;
-          if (lenTest2 >= 2)
+          unsigned offset = cur + len;
+          if (last < offset)
+            last = offset;
+        }
+        {
+          unsigned len2 = len;
+          price = repMatchPrice + GetPrice_PureRep(p, repIndex, state, posState);
+          do
           {
-            UInt32 nextRepMatchPrice;
-            UInt32 state2 = kRepNextStates[state];
-            UInt32 posStateNext = (position + lenTest) & p->pbMask;
-            UInt32 curAndLenCharPrice =
-                price + p->repLenEnc.prices[posState][(size_t)lenTest - 2] +
-                GET_PRICE_0(p->isMatch[state2][posStateNext]) +
-                LitEnc_GetPriceMatched(LIT_PROBS(position + lenTest, data[(size_t)lenTest - 1]),
-                    data[lenTest], data2[lenTest], p->ProbPrices);
-            state2 = kLiteralNextStates[state2];
-            posStateNext = (position + lenTest + 1) & p->pbMask;
-            nextRepMatchPrice = curAndLenCharPrice +
-                GET_PRICE_1(p->isMatch[state2][posStateNext]) +
-                GET_PRICE_1(p->isRep[state2]);
-            
-            /* for (; lenTest2 >= 2; lenTest2--) */
+            UInt32 price2 = price + GET_PRICE_LEN(&p->repLenEnc, posState, len2);
+            COptimal *opt = &p->opt[cur + len2];
+            if (price2 < opt->price)
             {
-              UInt32 curAndLenPrice;
-              COptimal *opt;
-              UInt32 offset = cur + lenTest + 1 + lenTest2;
-              while (lenEnd < offset)
-                p->opt[++lenEnd].price = kInfinityPrice;
-              curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
-              opt = &p->opt[offset];
-              if (curAndLenPrice < opt->price)
-              {
-                opt->price = curAndLenPrice;
-                opt->posPrev = cur + lenTest + 1;
-                opt->backPrev = 0;
-                opt->prev1IsChar = True;
-                opt->prev2 = True;
-                opt->posPrev2 = cur;
-                opt->backPrev2 = repIndex;
-              }
+              opt->price = price2;
+              opt->len = (UInt32)len2;
+              opt->dist = (UInt32)repIndex;
+              opt->extra = 0;
             }
           }
+          while (--len2 >= 2);
         }
+        
+        if (repIndex == 0) startLen = len + 1;  // 17.old
+        // startLen = len + 1; // 18.new
+
+        /* if (_maxMode) */
+        {
+          // ---------- REP : LIT : REP_0 ----------
+          // numFastBytes + 1 + numFastBytes
+
+          unsigned len2 = len + 1;
+          unsigned limit = len2 + p->numFastBytes;
+          if (limit > numAvailFull)
+            limit = numAvailFull;
+          
+          len2 += 2;
+          if (len2 <= limit)
+          if (data[len2 - 2] == data2[len2 - 2])
+          if (data[len2 - 1] == data2[len2 - 1])
+          {
+            unsigned state2 = kRepNextStates[state];
+            unsigned posState2 = (position + len) & p->pbMask;
+            price += GET_PRICE_LEN(&p->repLenEnc, posState, len)
+                + GET_PRICE_0(p->isMatch[state2][posState2])
+                + LitEnc_Matched_GetPrice(LIT_PROBS(position + len, data[(size_t)len - 1]),
+                    data[len], data2[len], p->ProbPrices);
+            
+            // state2 = kLiteralNextStates[state2];
+            state2 = kState_LitAfterRep;
+            posState2 = (posState2 + 1) & p->pbMask;
+
+
+            price += GetPrice_Rep_0(p, state2, posState2);
+
+          for (; len2 < limit && data[len2] == data2[len2]; len2++)
+          {}
+          
+          len2 -= len;
+          // if (len2 >= 3)
+          {
+            {
+              unsigned offset = cur + len + len2;
+
+              if (last < offset)
+                last = offset;
+              // do
+              {
+                UInt32 price2;
+                COptimal *opt;
+                len2--;
+                // price2 = price + GetPrice_Len_Rep_0(p, len2, state2, posState2);
+                price2 = price + GET_PRICE_LEN(&p->repLenEnc, posState2, len2);
+
+                opt = &p->opt[offset];
+                // offset--;
+                if (price2 < opt->price)
+                {
+                  opt->price = price2;
+                  opt->len = (UInt32)len2;
+                  opt->extra = (CExtra)(len + 1);
+                  opt->dist = (UInt32)repIndex;
+                }
+              }
+              // while (len2 >= 3);
+            }
+          }
+          }
+        }
+      }
     }
-    }
-    /* for (UInt32 lenTest = 2; lenTest <= newLen; lenTest++) */
+
+
+    // ---------- MATCH ----------
+    /* for (unsigned len = 2; len <= newLen; len++) */
     if (newLen > numAvail)
     {
       newLen = numAvail;
       for (numPairs = 0; newLen > matches[numPairs]; numPairs += 2);
-      matches[numPairs] = newLen;
+      matches[numPairs] = (UInt32)newLen;
       numPairs += 2;
     }
+    
+    // startLen = 2; /* speed optimization */
+
     if (newLen >= startLen)
     {
       UInt32 normalMatchPrice = matchPrice + GET_PRICE_0(p->isRep[state]);
-      UInt32 offs, curBack, posSlot;
-      UInt32 lenTest;
-      while (lenEnd < cur + newLen)
-        p->opt[++lenEnd].price = kInfinityPrice;
+      UInt32 dist;
+      unsigned offs, posSlot, len;
+      
+      {
+        unsigned offset = cur + newLen;
+        if (last < offset)
+          last = offset;
+      }
 
       offs = 0;
       while (startLen > matches[offs])
         offs += 2;
-      curBack = matches[(size_t)offs + 1];
-      GetPosSlot2(curBack, posSlot);
-      for (lenTest = /*2*/ startLen; ; lenTest++)
+      dist = matches[(size_t)offs + 1];
+      
+      // if (dist >= kNumFullDistances)
+      GetPosSlot2(dist, posSlot);
+      
+      for (len = /*2*/ startLen; ; len++)
       {
-        UInt32 curAndLenPrice = normalMatchPrice + p->lenEnc.prices[posState][(size_t)lenTest - LZMA_MATCH_LEN_MIN];
+        UInt32 price = normalMatchPrice + GET_PRICE_LEN(&p->lenEnc, posState, len);
         {
-        UInt32 lenToPosState = GetLenToPosState(lenTest);
-        COptimal *opt;
-        if (curBack < kNumFullDistances)
-          curAndLenPrice += p->distancesPrices[lenToPosState][curBack];
-        else
-          curAndLenPrice += p->posSlotPrices[lenToPosState][posSlot] + p->alignPrices[curBack & kAlignMask];
-        
-        opt = &p->opt[cur + lenTest];
-        if (curAndLenPrice < opt->price)
-        {
-          opt->price = curAndLenPrice;
-          opt->posPrev = cur;
-          opt->backPrev = curBack + LZMA_NUM_REPS;
-          opt->prev1IsChar = False;
-        }
+          COptimal *opt;
+          unsigned lenNorm = len - 2;
+          lenNorm = GetLenToPosState2(lenNorm);
+          if (dist < kNumFullDistances)
+            price += p->distancesPrices[lenNorm][dist & (kNumFullDistances - 1)];
+          else
+            price += p->posSlotPrices[lenNorm][posSlot] + p->alignPrices[dist & kAlignMask];
+          
+          opt = &p->opt[cur + len];
+          if (price < opt->price)
+          {
+            opt->price = price;
+            opt->len = (UInt32)len;
+            opt->dist = dist + LZMA_NUM_REPS;
+            opt->extra = 0;
+          }
         }
 
-        if (/*_maxMode && */lenTest == matches[offs])
+        if (len == matches[offs])
         {
-          /* Try Match + Literal + Rep0 */
-          const Byte *data2 = data - curBack - 1;
-          UInt32 lenTest2 = lenTest + 1;
-          UInt32 limit = lenTest2 + p->numFastBytes;
+          // if (p->_maxMode) {
+          // MATCH : LIT : REP_0
+
+          const Byte *data2 = data - dist - 1;
+          unsigned len2 = len + 1;
+          unsigned limit = len2 + p->numFastBytes;
           if (limit > numAvailFull)
             limit = numAvailFull;
-          for (; lenTest2 < limit && data[lenTest2] == data2[lenTest2]; lenTest2++);
-          lenTest2 -= lenTest + 1;
-          if (lenTest2 >= 2)
+          
+          len2 += 2;
+          if (len2 <= limit)
+          if (data[len2 - 2] == data2[len2 - 2])
+          if (data[len2 - 1] == data2[len2 - 1])
           {
-            UInt32 nextRepMatchPrice;
-            UInt32 state2 = kMatchNextStates[state];
-            UInt32 posStateNext = (position + lenTest) & p->pbMask;
-            UInt32 curAndLenCharPrice = curAndLenPrice +
-                GET_PRICE_0(p->isMatch[state2][posStateNext]) +
-                LitEnc_GetPriceMatched(LIT_PROBS(position + lenTest, data[(size_t)lenTest - 1]),
-                    data[lenTest], data2[lenTest], p->ProbPrices);
-            state2 = kLiteralNextStates[state2];
-            posStateNext = (posStateNext + 1) & p->pbMask;
-            nextRepMatchPrice = curAndLenCharPrice +
-                GET_PRICE_1(p->isMatch[state2][posStateNext]) +
-                GET_PRICE_1(p->isRep[state2]);
-            
-            /* for (; lenTest2 >= 2; lenTest2--) */
+          for (; len2 < limit && data[len2] == data2[len2]; len2++)
+          {}
+          
+          len2 -= len;
+          
+          // if (len2 >= 3)
+          {
+            unsigned state2 = kMatchNextStates[state];
+            unsigned posState2 = (position + len) & p->pbMask;
+            unsigned offset;
+            price += GET_PRICE_0(p->isMatch[state2][posState2]);
+            price += LitEnc_Matched_GetPrice(LIT_PROBS(position + len, data[(size_t)len - 1]),
+                    data[len], data2[len], p->ProbPrices);
+
+            // state2 = kLiteralNextStates[state2];
+            state2 = kState_LitAfterMatch;
+
+            posState2 = (posState2 + 1) & p->pbMask;
+            price += GetPrice_Rep_0(p, state2, posState2);
+
+            offset = cur + len + len2;
+
+            if (last < offset)
+              last = offset;
+            // do
             {
-              UInt32 offset = cur + lenTest + 1 + lenTest2;
-              UInt32 curAndLenPrice2;
+              UInt32 price2;
               COptimal *opt;
-              while (lenEnd < offset)
-                p->opt[++lenEnd].price = kInfinityPrice;
-              curAndLenPrice2 = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
+              len2--;
+              // price2 = price + GetPrice_Len_Rep_0(p, len2, state2, posState2);
+              price2 = price + GET_PRICE_LEN(&p->repLenEnc, posState2, len2);
               opt = &p->opt[offset];
-              if (curAndLenPrice2 < opt->price)
+              // offset--;
+              if (price2 < opt->price)
               {
-                opt->price = curAndLenPrice2;
-                opt->posPrev = cur + lenTest + 1;
-                opt->backPrev = 0;
-                opt->prev1IsChar = True;
-                opt->prev2 = True;
-                opt->posPrev2 = cur;
-                opt->backPrev2 = curBack + LZMA_NUM_REPS;
+                opt->price = price2;
+                opt->len = (UInt32)len2;
+                opt->extra = (CExtra)(len + 1);
+                opt->dist = dist + LZMA_NUM_REPS;
               }
             }
+            // while (len2 >= 3);
           }
+
+          }
+        
           offs += 2;
           if (offs == numPairs)
             break;
-          curBack = matches[(size_t)offs + 1];
-          if (curBack >= kNumFullDistances)
-            GetPosSlot2(curBack, posSlot);
+          dist = matches[(size_t)offs + 1];
+          // if (dist >= kNumFullDistances)
+            GetPosSlot2(dist, posSlot);
         }
       }
     }
   }
+
+  do
+    p->opt[last].price = kInfinityPrice;
+  while (--last);
+
+  return Backward(p, cur);
 }
 
+
+
 #define ChangePair(smallDist, bigDist) (((bigDist) >> 7) > (smallDist))
 
-static UInt32 GetOptimumFast(CLzmaEnc *p, UInt32 *backRes)
+
+
+static unsigned GetOptimumFast(CLzmaEnc *p)
 {
-  UInt32 numAvail, mainLen, mainDist, numPairs, repIndex, repLen, i;
+  UInt32 numAvail, mainDist;
+  unsigned mainLen, numPairs, repIndex, repLen, i;
   const Byte *data;
-  const UInt32 *matches;
 
   if (p->additionalOffset == 0)
     mainLen = ReadMatchDistances(p, &numPairs);
   else
   {
-    mainLen = p->longestMatchLength;
+    mainLen = p->longestMatchLen;
     numPairs = p->numPairs;
   }
 
   numAvail = p->numAvail;
-  *backRes = (UInt32)-1;
+  p->backRes = MARK_LIT;
   if (numAvail < 2)
     return 1;
+  // if (mainLen < 2 && p->state == 0) return 1; // 18.06.notused
   if (numAvail > LZMA_MATCH_LEN_MAX)
     numAvail = LZMA_MATCH_LEN_MAX;
   data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
-
   repLen = repIndex = 0;
+  
   for (i = 0; i < LZMA_NUM_REPS; i++)
   {
-    UInt32 len;
-    const Byte *data2 = data - p->reps[i] - 1;
+    unsigned len;
+    const Byte *data2 = data - p->reps[i];
     if (data[0] != data2[0] || data[1] != data2[1])
       continue;
-    for (len = 2; len < numAvail && data[len] == data2[len]; len++);
+    for (len = 2; len < numAvail && data[len] == data2[len]; len++)
+    {}
     if (len >= p->numFastBytes)
     {
-      *backRes = i;
-      MovePos(p, len - 1);
+      p->backRes = (UInt32)i;
+      MOVE_POS(p, len - 1)
       return len;
     }
     if (len > repLen)
