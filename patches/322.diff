diff --git a/C/XzDec.c b/C/XzDec.c
index 67216a5..395e83f 100644
--- a/C/XzDec.c
+++ b/C/XzDec.c
@@ -983,8 +983,1407 @@ Hunk #27, a/C/XzDec.c UInt64 XzUnpacker_GetExtraSize(const CXzUnpacker *p)
 {
   UInt64 num = 0;
   if (p->state == XZ_STATE_STREAM_PADDING)
-    num += p->padSize;
+    num = p->padSize;
   else if (p->state == XZ_STATE_STREAM_HEADER)
-    num += p->padSize + p->pos;
+    num = p->padSize + p->pos;
   return num;
 }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#ifndef _7ZIP_ST
+#include "MtDec.h"
+#endif
+
+
+void XzDecMtProps_Init(CXzDecMtProps *p)
+{
+  p->inBufSize_ST = 1 << 18;
+  p->outStep_ST = 1 << 20;
+  p->ignoreErrors = False;
+
+  #ifndef _7ZIP_ST
+  p->numThreads = 1;
+  p->inBufSize_MT = 1 << 18;
+  p->memUseMax = sizeof(size_t) << 28;
+  #endif
+}
+
+
+
+#ifndef _7ZIP_ST
+
+/* ---------- CXzDecMtThread ---------- */
+
+typedef struct
+{
+  Byte *outBuf;
+  size_t outBufSize;
+  size_t outPreSize;
+  size_t inPreSize;
+  size_t inPreHeaderSize;
+  size_t blockPackSize_for_Index;  // including block header and checksum.
+  size_t blockPackTotal;  // including stream header, block header and checksum.
+  size_t inCodeSize;
+  size_t outCodeSize;
+  ECoderStatus status;
+  SRes codeRes;
+  BoolInt skipMode;
+  // BoolInt finishedWithMark;
+  EMtDecParseState parseState;
+  BoolInt parsing_Truncated;
+  BoolInt atBlockHeader;
+  CXzStreamFlags streamFlags;
+  // UInt64 numFinishedStreams
+  UInt64 numStreams;
+  UInt64 numTotalBlocks;
+  UInt64 numBlocks;
+
+  BoolInt dec_created;
+  CXzUnpacker dec;
+
+  Byte mtPad[1 << 7];
+} CXzDecMtThread;
+
+#endif
+
+
+/* ---------- CXzDecMt ---------- */
+
+typedef struct
+{
+  CAlignOffsetAlloc alignOffsetAlloc;
+  ISzAllocPtr allocMid;
+
+  CXzDecMtProps props;
+  size_t unpackBlockMaxSize;
+  
+  ISeqInStream *inStream;
+  ISeqOutStream *outStream;
+  ICompressProgress *progress;
+  // CXzStatInfo *stat;
+
+  BoolInt finishMode;
+  BoolInt outSize_Defined;
+  UInt64 outSize;
+
+  UInt64 outProcessed;
+  UInt64 inProcessed;
+  UInt64 readProcessed;
+  BoolInt readWasFinished;
+  SRes readRes;
+  SRes writeRes;
+
+  Byte *outBuf;
+  size_t outBufSize;
+  Byte *inBuf;
+  size_t inBufSize;
+
+  CXzUnpacker dec;
+
+  ECoderStatus status;
+  SRes codeRes;
+
+  #ifndef _7ZIP_ST
+  BoolInt mainDecoderWasCalled;
+  // int statErrorDefined;
+  int finishedDecoderIndex;
+
+  // global values that are used in Parse stage
+  CXzStreamFlags streamFlags;
+  // UInt64 numFinishedStreams
+  UInt64 numStreams;
+  UInt64 numTotalBlocks;
+  UInt64 numBlocks;
+
+  // UInt64 numBadBlocks;
+  SRes mainErrorCode;
+
+  BoolInt isBlockHeaderState_Parse;
+  BoolInt isBlockHeaderState_Write;
+  UInt64 outProcessed_Parse;
+  BoolInt parsing_Truncated;
+
+  BoolInt mtc_WasConstructed;
+  CMtDec mtc;
+  CXzDecMtThread coders[MTDEC__THREADS_MAX];
+  #endif
+
+} CXzDecMt;
+
+
+
+CXzDecMtHandle XzDecMt_Create(ISzAllocPtr alloc, ISzAllocPtr allocMid)
+{
+  CXzDecMt *p = (CXzDecMt *)ISzAlloc_Alloc(alloc, sizeof(CXzDecMt));
+  if (!p)
+    return NULL;
+  
+  AlignOffsetAlloc_CreateVTable(&p->alignOffsetAlloc);
+  p->alignOffsetAlloc.baseAlloc = alloc;
+  p->alignOffsetAlloc.numAlignBits = 7;
+  p->alignOffsetAlloc.offset = 0;
+
+  p->allocMid = allocMid;
+
+  p->outBuf = NULL;
+  p->outBufSize = 0;
+  p->inBuf = NULL;
+  p->inBufSize = 0;
+
+  XzUnpacker_Construct(&p->dec, &p->alignOffsetAlloc.vt);
+
+  p->unpackBlockMaxSize = 0;
+
+  XzDecMtProps_Init(&p->props);
+
+  #ifndef _7ZIP_ST
+  p->mtc_WasConstructed = False;
+  {
+    unsigned i;
+    for (i = 0; i < MTDEC__THREADS_MAX; i++)
+    {
+      CXzDecMtThread *coder = &p->coders[i];
+      coder->dec_created = False;
+      coder->outBuf = NULL;
+      coder->outBufSize = 0;
+    }
+  }
+  #endif
+
+  return p;
+}
+
+
+#ifndef _7ZIP_ST
+
+static void XzDecMt_FreeOutBufs(CXzDecMt *p)
+{
+  unsigned i;
+  for (i = 0; i < MTDEC__THREADS_MAX; i++)
+  {
+    CXzDecMtThread *coder = &p->coders[i];
+    if (coder->outBuf)
+    {
+      ISzAlloc_Free(p->allocMid, coder->outBuf);
+      coder->outBuf = NULL;
+      coder->outBufSize = 0;
+    }
+  }
+  p->unpackBlockMaxSize = 0;
+}
+
+#endif
+
+
+
+static void XzDecMt_FreeSt(CXzDecMt *p)
+{
+  XzUnpacker_Free(&p->dec);
+  
+  if (p->outBuf)
+  {
+    ISzAlloc_Free(p->allocMid, p->outBuf);
+    p->outBuf = NULL;
+  }
+  p->outBufSize = 0;
+  
+  if (p->inBuf)
+  {
+    ISzAlloc_Free(p->allocMid, p->inBuf);
+    p->inBuf = NULL;
+  }
+  p->inBufSize = 0;
+}
+
+
+void XzDecMt_Destroy(CXzDecMtHandle pp)
+{
+  CXzDecMt *p = (CXzDecMt *)pp;
+
+  XzDecMt_FreeSt(p);
+
+  #ifndef _7ZIP_ST
+
+  if (p->mtc_WasConstructed)
+  {
+    MtDec_Destruct(&p->mtc);
+    p->mtc_WasConstructed = False;
+  }
+  {
+    unsigned i;
+    for (i = 0; i < MTDEC__THREADS_MAX; i++)
+    {
+      CXzDecMtThread *t = &p->coders[i];
+      if (t->dec_created)
+      {
+        // we don't need to free dict here
+        XzUnpacker_Free(&t->dec);
+        t->dec_created = False;
+      }
+    }
+  }
+  XzDecMt_FreeOutBufs(p);
+
+  #endif
+
+  ISzAlloc_Free(p->alignOffsetAlloc.baseAlloc, pp);
+}
+
+
+
+#ifndef _7ZIP_ST
+
+static void XzDecMt_Callback_Parse(void *obj, unsigned coderIndex, CMtDecCallbackInfo *cc)
+{
+  CXzDecMt *me = (CXzDecMt *)obj;
+  CXzDecMtThread *coder = &me->coders[coderIndex];
+  size_t srcSize = cc->srcSize;
+
+  cc->srcSize = 0;
+  cc->outPos = 0;
+  cc->state = MTDEC_PARSE_CONTINUE;
+
+  cc->canCreateNewThread = True;
+
+  if (cc->startCall)
+  {
+    coder->outPreSize = 0;
+    coder->inPreSize = 0;
+    coder->inPreHeaderSize = 0;
+    coder->parseState = MTDEC_PARSE_CONTINUE;
+    coder->parsing_Truncated = False;
+    coder->skipMode = False;
+    coder->codeRes = SZ_OK;
+    coder->status = CODER_STATUS_NOT_SPECIFIED;
+    coder->inCodeSize = 0;
+    coder->outCodeSize = 0;
+
+    coder->numStreams = me->numStreams;
+    coder->numTotalBlocks = me->numTotalBlocks;
+    coder->numBlocks = me->numBlocks;
+
+    if (!coder->dec_created)
+    {
+      XzUnpacker_Construct(&coder->dec, &me->alignOffsetAlloc.vt);
+      coder->dec_created = True;
+    }
+    
+    XzUnpacker_Init(&coder->dec);
+
+    if (me->isBlockHeaderState_Parse)
+    {
+      coder->dec.streamFlags = me->streamFlags;
+      coder->atBlockHeader = True;
+      XzUnpacker_PrepareToRandomBlockDecoding(&coder->dec);
+    }
+    else
+    {
+      coder->atBlockHeader = False;
+      me->isBlockHeaderState_Parse = True;
+    }
+
+    coder->dec.numStartedStreams = me->numStreams;
+    coder->dec.numTotalBlocks = me->numTotalBlocks;
+    coder->dec.numBlocks = me->numBlocks;
+  }
+
+  while (!coder->skipMode)
+  {
+    ECoderStatus status;
+    SRes res;
+    size_t srcSize2 = srcSize;
+    size_t destSize = (size_t)0 - 1;
+
+    coder->dec.parseMode = True;
+    coder->dec.headerParsedOk = False;
+    
+    PRF_STR_INT("Parse", srcSize2);
+    
+    res = XzUnpacker_Code(&coder->dec,
+        NULL, &destSize,
+        cc->src, &srcSize2, cc->srcFinished,
+        CODER_FINISH_END, &status);
+    
+    // PRF(printf(" res = %d, srcSize2 = %d", res, (unsigned)srcSize2));
+    
+    coder->codeRes = res;
+    coder->status = status;
+    cc->srcSize += srcSize2;
+    srcSize -= srcSize2;
+    coder->inPreHeaderSize += srcSize2;
+    coder->inPreSize = coder->inPreHeaderSize;
+    
+    if (res != SZ_OK)
+    {
+      cc->state =
+      coder->parseState = MTDEC_PARSE_END;
+      /*
+      if (res == SZ_ERROR_MEM)
+        return res;
+      return SZ_OK;
+      */
+      return; // res;
+    }
+    
+    if (coder->dec.headerParsedOk)
+    {
+      const CXzBlock *block = &coder->dec.block;
+      if (XzBlock_HasUnpackSize(block)
+          // && block->unpackSize <= me->props.outBlockMax
+          && XzBlock_HasPackSize(block))
+      {
+        {
+          if (block->unpackSize * 2 * me->mtc.numStartedThreads > me->props.memUseMax)
+          {
+            cc->state = MTDEC_PARSE_OVERFLOW;
+            return; // SZ_OK;
+          }
+        }
+        {
+        UInt64 packSize = block->packSize;
+        UInt64 packSizeAligned = packSize + ((0 - (unsigned)packSize) & 3);
+        UInt32 checkSize = XzFlags_GetCheckSize(coder->dec.streamFlags);
+        UInt64 blockPackSum = coder->inPreSize + packSizeAligned + checkSize;
+        // if (blockPackSum <= me->props.inBlockMax)
+        // unpackBlockMaxSize
+        {
+          coder->blockPackSize_for_Index = (size_t)(coder->dec.blockHeaderSize + packSize + checkSize);
+          coder->blockPackTotal = (size_t)blockPackSum;
+          coder->outPreSize = (size_t)block->unpackSize;
+          coder->streamFlags = coder->dec.streamFlags;
+          me->streamFlags = coder->dec.streamFlags;
+          coder->skipMode = True;
+          break;
+        }
+        }
+      }
+    }
+    else
+    // if (coder->inPreSize <= me->props.inBlockMax)
+    {
+      if (!cc->srcFinished)
+        return; // SZ_OK;
+      cc->state =
+      coder->parseState = MTDEC_PARSE_END;
+      return; // SZ_OK;
+    }
+    cc->state = MTDEC_PARSE_OVERFLOW;
+    return; // SZ_OK;
+  }
+
+  // ---------- skipMode ----------
+  {
+    UInt64 rem = coder->blockPackTotal - coder->inPreSize;
+    size_t cur = srcSize;
+    if (cur > rem)
+      cur = (size_t)rem;
+    cc->srcSize += cur;
+    coder->inPreSize += cur;
+    srcSize -= cur;
+
+    if (coder->inPreSize == coder->blockPackTotal)
+    {
+      if (srcSize == 0)
+      {
+        if (!cc->srcFinished)
+          return; // SZ_OK;
+        cc->state = MTDEC_PARSE_END;
+      }
+      else if ((cc->src)[cc->srcSize] == 0) // we check control byte of next block
+        cc->state = MTDEC_PARSE_END;
+      else
+      {
+        cc->state = MTDEC_PARSE_NEW;
+
+        {
+          size_t blockMax = me->unpackBlockMaxSize;
+          if (blockMax < coder->outPreSize)
+            blockMax = coder->outPreSize;
+          {
+            UInt64 required = (UInt64)blockMax * (me->mtc.numStartedThreads + 1) * 2;
+            if (me->props.memUseMax < required)
+              cc->canCreateNewThread = False;
+          }
+        }
+
+        if (me->outSize_Defined)
+        {
+          // next block can be zero size
+          const UInt64 rem2 = me->outSize - me->outProcessed_Parse;
+          if (rem2 < coder->outPreSize)
+          {
+            coder->parsing_Truncated = True;
+            cc->state = MTDEC_PARSE_END;
+          }
+          me->outProcessed_Parse += coder->outPreSize;
+        }
+      }
+    }
+    else if (cc->srcFinished)
+      cc->state = MTDEC_PARSE_END;
+    else
+      return; // SZ_OK;
+
+    coder->parseState = cc->state;
+    cc->outPos = coder->outPreSize;
+    
+    me->numStreams = coder->dec.numStartedStreams;
+    me->numTotalBlocks = coder->dec.numTotalBlocks;
+    me->numBlocks = coder->dec.numBlocks + 1;
+    return; // SZ_OK;
+  }
+}
+
+
+static SRes XzDecMt_Callback_PreCode(void *pp, unsigned coderIndex)
+{
+  CXzDecMt *me = (CXzDecMt *)pp;
+  CXzDecMtThread *coder = &me->coders[coderIndex];
+  Byte *dest;
+
+  if (!coder->dec.headerParsedOk)
+    return SZ_OK;
+
+  dest = coder->outBuf;
+
+  if (!dest || coder->outBufSize < coder->outPreSize)
+  {
+    if (dest)
+    {
+      ISzAlloc_Free(me->allocMid, dest);
+      coder->outBuf = NULL;
+      coder->outBufSize = 0;
+    }
+    {
+      size_t outPreSize = coder->outPreSize;
+      if (outPreSize == 0)
+        outPreSize = 1;
+      dest = (Byte *)ISzAlloc_Alloc(me->allocMid, outPreSize);
+    }
+    if (!dest)
+      return SZ_ERROR_MEM;
+    coder->outBuf = dest;
+    coder->outBufSize = coder->outPreSize;
+
+    if (coder->outBufSize > me->unpackBlockMaxSize)
+      me->unpackBlockMaxSize = coder->outBufSize;
+  }
+
+  // return SZ_ERROR_MEM;
+
+  XzUnpacker_SetOutBuf(&coder->dec, coder->outBuf, coder->outBufSize);
+
+  {
+    SRes res = XzDecMix_Init(&coder->dec.decoder, &coder->dec.block, coder->outBuf, coder->outBufSize);
+    // res = SZ_ERROR_UNSUPPORTED; // to test
+    coder->codeRes = res;
+    if (res != SZ_OK)
+    {
+      // if (res == SZ_ERROR_MEM) return res;
+      if (me->props.ignoreErrors && res != SZ_ERROR_MEM)
+        return S_OK;
+      return res;
+    }
+  }
+
+  return SZ_OK;
+}
+
+
+static SRes XzDecMt_Callback_Code(void *pp, unsigned coderIndex,
+    const Byte *src, size_t srcSize, int srcFinished,
+    // int finished, int blockFinished,
+    UInt64 *inCodePos, UInt64 *outCodePos, int *stop)
+{
+  CXzDecMt *me = (CXzDecMt *)pp;
+  CXzDecMtThread *coder = &me->coders[coderIndex];
+
+  *inCodePos = coder->inCodeSize;
+  *outCodePos = coder->outCodeSize;
+  *stop = True;
+
+  if (coder->inCodeSize < coder->inPreHeaderSize)
+  {
+    UInt64 rem = coder->inPreHeaderSize - coder->inCodeSize;
+    size_t step = srcSize;
+    if (step > rem)
+      step = (size_t)rem;
+    src += step;
+    srcSize -= step;
+    coder->inCodeSize += step;
+    if (coder->inCodeSize < coder->inPreHeaderSize)
+    {
+      *stop = False;
+      return SZ_OK;
+    }
+  }
+
+  if (!coder->dec.headerParsedOk)
+    return SZ_OK;
+  if (!coder->outBuf)
+    return SZ_OK;
+
+  if (coder->codeRes == SZ_OK)
+  {
+    ECoderStatus status;
+    SRes res;
+    size_t srcProcessed = srcSize;
+    size_t outSizeCur = coder->outPreSize - coder->dec.outDataWritten;
+
+    // PRF(printf("\nCallback_Code: Code %d %d\n", (unsigned)srcSize, (unsigned)outSizeCur));
+
+    res = XzUnpacker_Code(&coder->dec,
+        NULL, &outSizeCur,
+        src, &srcProcessed, srcFinished,
+        // coder->finishedWithMark ? CODER_FINISH_END : CODER_FINISH_ANY,
+        CODER_FINISH_END,
+        &status);
+
+    // PRF(printf(" res = %d, srcSize2 = %d, outSizeCur = %d", res, (unsigned)srcProcessed, (unsigned)outSizeCur));
+
+    coder->codeRes = res;
+    coder->status = status;
+    coder->inCodeSize += srcProcessed;
+    coder->outCodeSize = coder->dec.outDataWritten;
+    *inCodePos = coder->inCodeSize;
+    *outCodePos = coder->outCodeSize;
+
+    if (res == SZ_OK)
+    {
+      if (srcProcessed == srcSize)
+        *stop = False;
+      return SZ_OK;
+    }
+  }
+
+  if (me->props.ignoreErrors && coder->codeRes != SZ_ERROR_MEM)
+  {
+    *inCodePos = coder->inPreSize;
+    *outCodePos = coder->outPreSize;
+    return S_OK;
+  }
+  return coder->codeRes;
+}
+
+
+#define XZDECMT_STREAM_WRITE_STEP (1 << 24)
+
+static SRes XzDecMt_Callback_Write(void *pp, unsigned coderIndex,
+    BoolInt needWriteToStream,
+    const Byte *src, size_t srcSize,
+    // int srcFinished,
+    BoolInt *needContinue,
+    BoolInt *canRecode)
+{
+  CXzDecMt *me = (CXzDecMt *)pp;
+  const CXzDecMtThread *coder = &me->coders[coderIndex];
+
+  // PRF(printf("\nWrite processed = %d srcSize = %d\n", (unsigned)me->mtc.inProcessed, (unsigned)srcSize));
+  
+  *needContinue = False;
+  *canRecode = True;
+  
+  if (!needWriteToStream)
+    return SZ_OK;
+
+  if (!coder->dec.headerParsedOk || !coder->outBuf)
+  {
+    if (me->finishedDecoderIndex < 0)
+      me->finishedDecoderIndex = coderIndex;
+    return SZ_OK;
+  }
+
+  if (me->finishedDecoderIndex >= 0)
+    return SZ_OK;
+
+  me->mtc.inProcessed += coder->inCodeSize;
+
+  *canRecode = False;
+
+  {
+    SRes res;
+    size_t size = coder->outCodeSize;
+    Byte *data = coder->outBuf;
+    
+    // we use in me->dec: sha, numBlocks, indexSize
+
+    if (!me->isBlockHeaderState_Write)
+    {
+      XzUnpacker_PrepareToRandomBlockDecoding(&me->dec);
+      me->dec.decodeOnlyOneBlock = False;
+      me->dec.numStartedStreams = coder->dec.numStartedStreams;
+      me->dec.streamFlags = coder->streamFlags;
+
+      me->isBlockHeaderState_Write = True;
+    }
+    
+    me->dec.numTotalBlocks = coder->dec.numTotalBlocks;
+    XzUnpacker_UpdateIndex(&me->dec, coder->blockPackSize_for_Index, coder->outPreSize);
+    
+    if (coder->outPreSize != size)
+    {
+      if (me->props.ignoreErrors)
+      {
+        memset(data + size, 0, coder->outPreSize - size);
+        size = coder->outPreSize;
+      }
+      // me->numBadBlocks++;
+      if (me->mainErrorCode == SZ_OK)
+      {
+        if ((int)coder->status == LZMA_STATUS_NEEDS_MORE_INPUT)
+          me->mainErrorCode = SZ_ERROR_INPUT_EOF;
+        else
+          me->mainErrorCode = SZ_ERROR_DATA;
+      }
+    }
+    
+    if (me->writeRes != SZ_OK)
+      return me->writeRes;
+
+    res = SZ_OK;
+    {
+      if (me->outSize_Defined)
+      {
+        const UInt64 rem = me->outSize - me->outProcessed;
+        if (size > rem)
+          size = (SizeT)rem;
+      }
+
+      for (;;)
+      {
+        size_t cur = size;
+        size_t written;
+        if (cur > XZDECMT_STREAM_WRITE_STEP)
+          cur = XZDECMT_STREAM_WRITE_STEP;
+
+        written = ISeqOutStream_Write(me->outStream, data, cur);
+
+        // PRF(printf("\nWritten ask = %d written = %d\n", (unsigned)cur, (unsigned)written));
+        
+        me->outProcessed += written;
+        if (written != cur)
+        {
+          me->writeRes = SZ_ERROR_WRITE;
+          res = me->writeRes;
+          break;
+        }
+        data += cur;
+        size -= cur;
+        // PRF_STR_INT("Written size =", size);
+        if (size == 0)
+          break;
+        res = MtProgress_ProgressAdd(&me->mtc.mtProgress, 0, 0);
+        if (res != SZ_OK)
+          break;
+      }
+    }
+
+    if (coder->codeRes != SZ_OK)
+      if (!me->props.ignoreErrors)
+      {
+        me->finishedDecoderIndex = coderIndex;
+        return res;
+      }
+
+    RINOK(res);
+
+    if (coder->inPreSize != coder->inCodeSize
+        || coder->blockPackTotal != coder->inCodeSize)
+    {
+      me->finishedDecoderIndex = coderIndex;
+      return SZ_OK;
+    }
+
+    if (coder->parseState != MTDEC_PARSE_END)
+    {
+      *needContinue = True;
+      return SZ_OK;
+    }
+  }
+
+  // (coder->state == MTDEC_PARSE_END) means that there are no other working threads
+  // so we can use mtc variables without lock
+
+  PRF_STR_INT("Write MTDEC_PARSE_END", me->mtc.inProcessed);
+
+  me->mtc.mtProgress.totalInSize = me->mtc.inProcessed;
+  {
+    CXzUnpacker *dec = &me->dec;
+    
+    PRF_STR_INT("PostSingle", srcSize);
+    
+    {
+      size_t srcProcessed = srcSize;
+      ECoderStatus status;
+      size_t outSizeCur = 0;
+      SRes res;
+      
+      // dec->decodeOnlyOneBlock = False;
+      dec->decodeToStreamSignature = True;
+
+      me->mainDecoderWasCalled = True;
+
+      if (coder->parsing_Truncated)
+      {
+        me->parsing_Truncated = True;
+        return SZ_OK;
+      }
+      
+      res = XzUnpacker_Code(dec,
+          NULL, &outSizeCur,
+          src, &srcProcessed,
+          me->mtc.readWasFinished, // srcFinished
+          CODER_FINISH_END, // CODER_FINISH_ANY,
+          &status);
+      
+      me->status = status;
+      me->codeRes = res;
+
+      me->mtc.inProcessed += srcProcessed;
+      me->mtc.mtProgress.totalInSize = me->mtc.inProcessed;
+
+      if (res != SZ_OK)
+      {
+        return S_OK;
+        // return res;
+      }
+      
+      if (dec->state == XZ_STATE_STREAM_HEADER)
+      {
+        *needContinue = True;
+        me->isBlockHeaderState_Parse = False;
+        me->isBlockHeaderState_Write = False;
+        {
+          Byte *crossBuf = MtDec_GetCrossBuff(&me->mtc);
+          if (!crossBuf)
+            return SZ_ERROR_MEM;
+          memcpy(crossBuf, src + srcProcessed, srcSize - srcProcessed);
+        }
+        me->mtc.crossStart = 0;
+        me->mtc.crossEnd = srcSize - srcProcessed;
+        return SZ_OK;
+      }
+      
+      if (status != CODER_STATUS_NEEDS_MORE_INPUT)
+      {
+        return E_FAIL;
+      }
+      
+      if (me->mtc.readWasFinished)
+      {
+        return SZ_OK;
+      }
+    }
+    
+    {
+      size_t inPos;
+      size_t inLim;
+      const Byte *inData;
+      UInt64 inProgressPrev = me->mtc.inProcessed;
+      
+      // XzDecMt_Prepare_InBuf_ST(p);
+      Byte *crossBuf = MtDec_GetCrossBuff(&me->mtc);
+      if (!crossBuf)
+        return SZ_ERROR_MEM;
+      
+      inPos = 0;
+      inLim = 0;
+      // outProcessed = 0;
+      
+      inData = crossBuf;
+      
+      for (;;)
+      {
+        SizeT inProcessed;
+        SizeT outProcessed;
+        ECoderStatus status;
+        SRes res;
+        
+        if (inPos == inLim)
+        {
+          if (!me->mtc.readWasFinished)
+          {
+            inPos = 0;
+            inLim = me->mtc.inBufSize;
+            me->mtc.readRes = ISeqInStream_Read(me->inStream, (void *)inData, &inLim);
+            me->mtc.readProcessed += inLim;
+            if (inLim == 0 || me->mtc.readRes != SZ_OK)
+              me->mtc.readWasFinished = True;
+          }
+        }
+        
+        inProcessed = inLim - inPos;
+        outProcessed = 0;
+
+        res = XzUnpacker_Code(dec,
+            NULL, &outProcessed,
+            inData + inPos, &inProcessed,
+            (inProcessed == 0), // srcFinished
+            CODER_FINISH_END, &status);
+        
+        me->codeRes = res;
+        me->status = status;
+        inPos += inProcessed;
+        me->mtc.inProcessed += inProcessed;
+        me->mtc.mtProgress.totalInSize = me->mtc.inProcessed;
+
+        if (res != SZ_OK)
+        {
+          return S_OK;
+          // return res;
+        }
+
+        if (dec->state == XZ_STATE_STREAM_HEADER)
+        {
+          *needContinue = True;
+          me->mtc.crossStart = inPos;
+          me->mtc.crossEnd = inLim;
+          me->isBlockHeaderState_Parse = False;
+          me->isBlockHeaderState_Write = False;
+          return SZ_OK;
+        }
+        
+        if (status != CODER_STATUS_NEEDS_MORE_INPUT)
+          return E_FAIL;
+        
+        if (me->mtc.progress)
+        {
+          UInt64 inDelta = me->mtc.inProcessed - inProgressPrev;
+          if (inDelta >= (1 << 22))
+          {
+            RINOK(MtProgress_Progress_ST(&me->mtc.mtProgress));
+            inProgressPrev = me->mtc.inProcessed;
+          }
+        }
+        if (me->mtc.readWasFinished)
+          return SZ_OK;
+      }
+    }
+  }
+}
+
+
+#endif
+
+
+
+void XzStatInfo_Clear(CXzStatInfo *p)
+{
+  p->InSize = 0;
+  p->OutSize = 0;
+  
+  p->NumStreams = 0;
+  p->NumBlocks = 0;
+  
+  p->UnpackSize_Defined = False;
+  
+  p->NumStreams_Defined = False;
+  p->NumBlocks_Defined = False;
+  
+  // p->IsArc = False;
+  // p->UnexpectedEnd = False;
+  // p->Unsupported = False;
+  // p->HeadersError = False;
+  // p->DataError = False;
+  // p->CrcError = False;
+
+  p->DataAfterEnd = False;
+  p->DecodingTruncated = False;
+  
+  p->DecodeRes = SZ_OK;
+  p->ReadRes = SZ_OK;
+  p->ProgressRes = SZ_OK;
+
+  p->CombinedRes = SZ_OK;
+  p->CombinedRes_Type = SZ_OK;
+}
+
+
+
+
+static SRes XzDecMt_Decode_ST(CXzDecMt *p
+    #ifndef _7ZIP_ST
+    , BoolInt tMode
+    #endif
+    , CXzStatInfo *stat)
+{
+  size_t outPos;
+  size_t inPos, inLim;
+  const Byte *inData;
+  UInt64 inPrev, outPrev;
+
+  CXzUnpacker *dec;
+
+  #ifndef _7ZIP_ST
+  if (tMode)
+  {
+    XzDecMt_FreeOutBufs(p);
+    tMode = MtDec_PrepareRead(&p->mtc);
+  }
+  #endif
+
+  if (!p->outBuf || p->outBufSize != p->props.outStep_ST)
+  {
+    ISzAlloc_Free(p->allocMid, p->outBuf);
+    p->outBufSize = 0;
+    p->outBuf = (Byte *)ISzAlloc_Alloc(p->allocMid, p->props.outStep_ST);
+    if (!p->outBuf)
+      return SZ_ERROR_MEM;
+    p->outBufSize = p->props.outStep_ST;
+  }
+
+  if (!p->inBuf || p->inBufSize != p->props.inBufSize_ST)
+  {
+    ISzAlloc_Free(p->allocMid, p->inBuf);
+    p->inBufSize = 0;
+    p->inBuf = (Byte *)ISzAlloc_Alloc(p->allocMid, p->props.inBufSize_ST);
+    if (!p->inBuf)
+      return SZ_ERROR_MEM;
+    p->inBufSize = p->props.inBufSize_ST;
+  }
+
+  dec = &p->dec;
+  dec->decodeToStreamSignature = False;
+  // dec->decodeOnlyOneBlock = False;
+
+  XzUnpacker_SetOutBuf(dec, NULL, 0);
+
+  inPrev = p->inProcessed;
+  outPrev = p->outProcessed;
+
+  inPos = 0;
+  inLim = 0;
+  inData = NULL;
+  outPos = 0;
+
+  for (;;)
+  {
+    SizeT outSize;
+    BoolInt finished;
+    ECoderFinishMode finishMode;
+    SizeT inProcessed;
+    ECoderStatus status;
+    SRes res;
+
+    SizeT outProcessed;
+
+
+
+    if (inPos == inLim)
+    {
+      #ifndef _7ZIP_ST
+      if (tMode)
+      {
+        inData = MtDec_Read(&p->mtc, &inLim);
+        inPos = 0;
+        if (inData)
+          continue;
+        tMode = False;
+        inLim = 0;
+      }
+      #endif
+      
+      if (!p->readWasFinished)
+      {
+        inPos = 0;
+        inLim = p->inBufSize;
+        inData = p->inBuf;
+        p->readRes = ISeqInStream_Read(p->inStream, (void *)inData, &inLim);
+        p->readProcessed += inLim;
+        if (inLim == 0 || p->readRes != SZ_OK)
+          p->readWasFinished = True;
+      }
+    }
+
+    outSize = p->props.outStep_ST - outPos;
+
+    finishMode = CODER_FINISH_ANY;
+    if (p->outSize_Defined)
+    {
+      const UInt64 rem = p->outSize - p->outProcessed;
+      if (outSize >= rem)
+      {
+        outSize = (SizeT)rem;
+        if (p->finishMode)
+          finishMode = CODER_FINISH_END;
+      }
+    }
+
+    inProcessed = inLim - inPos;
+    outProcessed = outSize;
+
+    res = XzUnpacker_Code(dec, p->outBuf + outPos, &outProcessed,
+        inData + inPos, &inProcessed,
+        (inPos == inLim), // srcFinished
+        finishMode, &status);
+
+    p->codeRes = res;
+    p->status = status;
+
+    inPos += inProcessed;
+    outPos += outProcessed;
+    p->inProcessed += inProcessed;
+    p->outProcessed += outProcessed;
+
+    finished = ((inProcessed == 0 && outProcessed == 0) || res != SZ_OK);
+
+    if (finished || outProcessed >= outSize)
+      if (outPos != 0)
+      {
+        size_t written = ISeqOutStream_Write(p->outStream, p->outBuf, outPos);
+        p->outProcessed += written;
+        if (written != outPos)
+        {
+          stat->CombinedRes_Type = SZ_ERROR_WRITE;
+          return SZ_ERROR_WRITE;
+        }
+        outPos = 0;
+      }
+
+    if (p->progress && res == SZ_OK)
+    {
+      UInt64 inDelta = p->inProcessed - inPrev;
+      UInt64 outDelta = p->outProcessed - outPrev;
+      if (inDelta >= (1 << 22) || outDelta >= (1 << 22))
+      {
+        res = ICompressProgress_Progress(p->progress, p->inProcessed, p->outProcessed);
+        if (res != SZ_OK)
+        {
+          stat->CombinedRes_Type = SZ_ERROR_PROGRESS;
+          stat->ProgressRes = res;
+          return res;
+        }
+        inPrev = p->inProcessed;
+        outPrev = p->outProcessed;
+      }
+    }
+
+    if (finished)
+      return res;
+  }
+}
+
+static SRes XzStatInfo_SetStat(const CXzUnpacker *dec,
+    int finishMode,
+    UInt64 readProcessed, UInt64 inProcessed,
+    SRes res, ECoderStatus status,
+    BoolInt decodingTruncated,
+    CXzStatInfo *stat)
+{
+  UInt64 extraSize;
+  
+  stat->DecodingTruncated = (Byte)(decodingTruncated ? 1 : 0);
+  stat->InSize = inProcessed;
+  stat->NumStreams = dec->numStartedStreams;
+  stat->NumBlocks = dec->numTotalBlocks;
+  
+  stat->UnpackSize_Defined = True;
+  stat->NumStreams_Defined = True;
+  stat->NumBlocks_Defined = True;
+  
+  extraSize = XzUnpacker_GetExtraSize(dec);
+  
+  if (res == SZ_OK)
+  {
+    if (status == CODER_STATUS_NEEDS_MORE_INPUT)
+    {
+      // CODER_STATUS_NEEDS_MORE_INPUT is expected status for correct xz streams
+      extraSize = 0;
+      if (!XzUnpacker_IsStreamWasFinished(dec))
+        res = SZ_ERROR_INPUT_EOF;
+    }
+    else if (!decodingTruncated || finishMode) // (status == CODER_STATUS_NOT_FINISHED)
+      res = SZ_ERROR_DATA;
+  }
+  else if (res == SZ_ERROR_NO_ARCHIVE)
+  {
+    /*
+    SZ_ERROR_NO_ARCHIVE is possible for 2 states:
+      XZ_STATE_STREAM_HEADER  - if bad signature or bad CRC
+      XZ_STATE_STREAM_PADDING - if non-zero padding data
+    extraSize / inProcessed don't include "bad" byte
+    */
+    if (inProcessed != extraSize) // if good streams before error
+      if (extraSize != 0 || readProcessed != inProcessed)
+      {
+        stat->DataAfterEnd = True;
+        // there is some good xz stream before. So we set SZ_OK
+        res = SZ_OK;
+      }
+  }
+  
+  stat->DecodeRes = res;
+
+  stat->InSize -= extraSize;
+  return res;
+}
+
+
+SRes XzDecMt_Decode(CXzDecMtHandle pp,
+    const CXzDecMtProps *props,
+    const UInt64 *outDataSize, int finishMode,
+    ISeqOutStream *outStream,
+    // Byte *outBuf, size_t *outBufSize,
+    ISeqInStream *inStream,
+    // const Byte *inData, size_t inDataSize,
+    CXzStatInfo *stat,
+    int *isMT,
+    ICompressProgress *progress)
+{
+  CXzDecMt *p = (CXzDecMt *)pp;
+  #ifndef _7ZIP_ST
+  BoolInt tMode;
+  #endif
+
+  XzStatInfo_Clear(stat);
+
+  p->props = *props;
+
+  p->inStream = inStream;
+  p->outStream = outStream;
+  p->progress = progress;
+  // p->stat = stat;
+
+  p->outSize = 0;
+  p->outSize_Defined = False;
+  if (outDataSize)
+  {
+    p->outSize_Defined = True;
+    p->outSize = *outDataSize;
+  }
+
+  p->finishMode = finishMode;
+
+  // p->outSize = 457; p->outSize_Defined = True; p->finishMode = False; // for test
+
+  p->writeRes = SZ_OK;
+  p->outProcessed = 0;
+  p->inProcessed = 0;
+  p->readProcessed = 0;
+  p->readWasFinished = False;
+
+  p->codeRes = 0;
+  p->status = CODER_STATUS_NOT_SPECIFIED;
+
+  XzUnpacker_Init(&p->dec);
+
+  *isMT = False;
+
+    /*
+    p->outBuf = NULL;
+    p->outBufSize = 0;
+    if (!outStream)
+    {
+      p->outBuf = outBuf;
+      p->outBufSize = *outBufSize;
+      *outBufSize = 0;
+    }
+    */
+
+  
+  #ifndef _7ZIP_ST
+
+  p->isBlockHeaderState_Parse = False;
+  p->isBlockHeaderState_Write = False;
+  // p->numBadBlocks = 0;
+  p->mainErrorCode = SZ_OK;
+  p->mainDecoderWasCalled = False;
+
+  tMode = False;
+
+  if (p->props.numThreads > 1)
+  {
+    IMtDecCallback vt;
+
+    // we just free ST buffers here
+    // but we still keep state variables, that was set in XzUnpacker_Init()
+    XzDecMt_FreeSt(p);
+
+    p->outProcessed_Parse = 0;
+    p->parsing_Truncated = False;
+
+    p->numStreams = 0;
+    p->numTotalBlocks = 0;
+    p->numBlocks = 0;
+    p->finishedDecoderIndex = -1;
+
+    if (!p->mtc_WasConstructed)
+    {
+      p->mtc_WasConstructed = True;
+      MtDec_Construct(&p->mtc);
+    }
+    
+    p->mtc.mtCallback = &vt;
+    p->mtc.mtCallbackObject = p;
+
+    p->mtc.progress = progress;
+    p->mtc.inStream = inStream;
+    p->mtc.alloc = &p->alignOffsetAlloc.vt;
+    // p->mtc.inData = inData;
+    // p->mtc.inDataSize = inDataSize;
+    p->mtc.inBufSize = p->props.inBufSize_MT;
+    // p->mtc.inBlockMax = p->props.inBlockMax;
+    p->mtc.numThreadsMax = p->props.numThreads;
+
+    *isMT = True;
+
+    vt.Parse = XzDecMt_Callback_Parse;
+    vt.PreCode = XzDecMt_Callback_PreCode;
+    vt.Code = XzDecMt_Callback_Code;
+    vt.Write = XzDecMt_Callback_Write;
+
+    {
+      BoolInt needContinue;
+      
+      SRes res = MtDec_Code(&p->mtc);
+
+      stat->InSize = p->mtc.inProcessed;
+
+      p->inProcessed = p->mtc.inProcessed;
+      p->readRes = p->mtc.readRes;
+      p->readWasFinished = p->mtc.readWasFinished;
+      p->readProcessed = p->mtc.readProcessed;
+
+      tMode = True;
+      needContinue = False;
+
+      if (res == SZ_OK)
+      {
+        if (p->mtc.mtProgress.res != SZ_OK)
+        {
+          res = p->mtc.mtProgress.res;
+          stat->ProgressRes = res;
+          stat->CombinedRes_Type = SZ_ERROR_PROGRESS;
+        }
+        else
+          needContinue = p->mtc.needContinue;
+      }
+
+      if (!needContinue)
+      {
+        SRes codeRes;
+        BoolInt truncated = False;
+        ECoderStatus status;
+        CXzUnpacker *dec;
+
+        stat->OutSize = p->outProcessed;
+       
+        if (p->finishedDecoderIndex >= 0)
+        {
+          CXzDecMtThread *coder = &p->coders[(unsigned)p->finishedDecoderIndex];
+          codeRes = coder->codeRes;
+          dec = &coder->dec;
+          status = coder->status;
+        }
+        else if (p->mainDecoderWasCalled)
+        {
+          codeRes = p->codeRes;
+          dec = &p->dec;
+          status = p->status;
+          truncated = p->parsing_Truncated;
+        }
+        else
+          return E_FAIL;
+
+        XzStatInfo_SetStat(dec, p->finishMode,
+            p->mtc.readProcessed, p->mtc.inProcessed,
+            codeRes, status,
+            truncated,
+            stat);
+
+        if (res == SZ_OK)
+        {
+          if (p->writeRes != SZ_OK)
+          {
+            res = p->writeRes;
+            stat->CombinedRes_Type = SZ_ERROR_WRITE;
+          }
+          else if (p->mtc.readRes != SZ_OK && p->mtc.inProcessed == p->mtc.readProcessed)
+          {
+            res = p->mtc.readRes;
+            stat->ReadRes = res;
+            stat->CombinedRes_Type = SZ_ERROR_READ;
+          }
+          else if (p->mainErrorCode != SZ_OK)
+          {
+            res = p->mainErrorCode;
+          }
+        }
+
+        stat->CombinedRes = res;
+        if (stat->CombinedRes_Type == SZ_OK)
+          stat->CombinedRes_Type = res;
+        return res;
+      }
+
+      PRF_STR("----- decoding ST -----");
+    }
+  }
+
+  #endif
+
+
+  *isMT = False;
+
+  {
+    SRes res = XzDecMt_Decode_ST(p
+        #ifndef _7ZIP_ST
+        , tMode
+        #endif
+        , stat
+        );
+
+    XzStatInfo_SetStat(&p->dec,
+        p->finishMode,
+        p->readProcessed, p->inProcessed,
+        p->codeRes, p->status,
+        False, // truncated
+        stat);
+
+    if (res == SZ_OK)
+    {
+      /*
+      if (p->writeRes != SZ_OK)
+      {
+        res = p->writeRes;
+        stat->CombinedRes_Type = SZ_ERROR_WRITE;
+      }
+      else
+      */
+      if (p->readRes != SZ_OK && p->inProcessed == p->readProcessed)
+      {
+        res = p->readRes;
+        stat->ReadRes = res;
+        stat->CombinedRes_Type = SZ_ERROR_READ;
+      }
+      #ifndef _7ZIP_ST
+      else if (p->mainErrorCode != SZ_OK)
+        res = p->mainErrorCode;
+      #endif
+    }
+
+    stat->CombinedRes = res;
+    if (stat->CombinedRes_Type == SZ_OK)
+      stat->CombinedRes_Type = res;
+    return res;
+  }
+}
