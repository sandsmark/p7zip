diff --git a/C/LzFindMt.c b/C/LzFindMt.c
index 65c9ffd..bb0f42c 100644
--- a/C/LzFindMt.c
+++ b/C/LzFindMt.c
@@ -232,38 +232,57 @@ Hunk #2, a/C/LzFindMt.c static void MatchFinderMt_GetNextBlock_Hash(CMatchFinderMt *p)
 
 #define kEmptyHashValue 0
 
-/* #define MFMT_GM_INLINE */
+#define MFMT_GM_INLINE
 
 #ifdef MFMT_GM_INLINE
 
-#define NO_INLINE MY_FAST_CALL
+/*
+  we use size_t for _cyclicBufferPos instead of UInt32
+  to eliminate "movsx" BUG in old MSVC x64 compiler.
+*/
 
-static Int32 NO_INLINE GetMatchesSpecN(UInt32 lenLimit, UInt32 pos, const Byte *cur, CLzRef *son,
-    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 _cutValue,
-    UInt32 *_distances, UInt32 _maxLen, const UInt32 *hash, Int32 limit, UInt32 size, UInt32 *posRes)
+MY_NO_INLINE
+static UInt32 *GetMatchesSpecN(UInt32 lenLimit, UInt32 pos, const Byte *cur, CLzRef *son,
+    size_t _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 _cutValue,
+    UInt32 *distances, UInt32 _maxLen, const UInt32 *hash, const UInt32 *limit, UInt32 size, UInt32 *posRes)
 {
   do
   {
-  UInt32 *distances = _distances + 1;
-  UInt32 curMatch = pos - *hash++;
+  UInt32 *_distances = ++distances;
+  UInt32 delta = *hash++;
 
-  CLzRef *ptr0 = son + (_cyclicBufferPos << 1) + 1;
-  CLzRef *ptr1 = son + (_cyclicBufferPos << 1);
-  UInt32 len0 = 0, len1 = 0;
+  CLzRef *ptr0 = son + ((size_t)_cyclicBufferPos << 1) + 1;
+  CLzRef *ptr1 = son + ((size_t)_cyclicBufferPos << 1);
+  unsigned len0 = 0, len1 = 0;
   UInt32 cutValue = _cutValue;
-  UInt32 maxLen = _maxLen;
-  for (;;)
+  unsigned maxLen = (unsigned)_maxLen;
+
+  /*
+  if (size > 1)
   {
-    UInt32 delta = pos - curMatch;
-    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
+    UInt32 delta = *hash;
+    if (delta < _cyclicBufferSize)
     {
-      *ptr0 = *ptr1 = kEmptyHashValue;
-      break;
+      UInt32 cyc1 = _cyclicBufferPos + 1;
+      CLzRef *pair = son + ((size_t)(cyc1 - delta + ((delta > cyc1) ? _cyclicBufferSize : 0)) << 1);
+      Byte b = *(cur + 1 - delta);
+      _distances[0] = pair[0];
+      _distances[1] = b;
     }
+  }
+  */
+  if (cutValue == 0 || delta >= _cyclicBufferSize)
+  {
+    *ptr0 = *ptr1 = kEmptyHashValue;
+  }
+  else
+  for(;;)
+  {
     {
-      CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)) << 1);
+      CLzRef *pair = son + ((size_t)(_cyclicBufferPos - delta + ((_cyclicBufferPos < delta) ? _cyclicBufferSize : 0)) << 1);
       const Byte *pb = cur - delta;
-      UInt32 len = (len0 < len1 ? len0 : len1);
+      unsigned len = (len0 < len1 ? len0 : len1);
+      UInt32 pair0 = *pair;
       if (pb[len] == cur[len])
       {
         if (++len != lenLimit && pb[len] == cur[len])
